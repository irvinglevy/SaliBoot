/*
 * File:  Sensor_Service.c
 * Version: V1.0
 * Release Date 1 Aug 2016
 * Copyright (c) 2016 Commwell Research & Development Ltd. All rights reserved.
 *
 * Revision History:
 */

#include "driverlib.h"
#include "def.h"
#include "CardioSPI.h"
#include "BlueNRG.h"
#include "buffer.h"
#include "events.h"
#include "aci.h"
#include "aci_constants.h"
#include "sensor_service.h"
#include "BlueNRG_gatt_constants.h"
#include "hci.h"
#include "link_layer.h"
#include "gatt_server.h"
#include "adc.h"
#include <string.h>
 uint32_t missedPackets=0;
 uint32_t timer = 10000000;
 int connected = FALSE;
 uint8_t set_connectable = 1;
 uint16_t connection_handle = 0;
 uint8_t notification_enabled = FALSE;
uint16_t sampleServHandle, TXCharHandle, RXCharHandle;
uint16_t accServHandle, /*freeFallCharHandle,*/ accCharHandle, accCharDescHandle;
uint16_t envSensServHandle, tempCharHandle, pressCharHandle, humidityCharHandle;
uint16_t swServHandle,swCharHandle,swCharDescHAndle;
extern uint8_t first_connection;
uint8_t allowTX=0;
extern uint8_t TX_Pool_Available_Flag;
extern uint8_t ecg_new_packet[20];
#define COPY_UUID_128(uuid_struct, uuid_15, uuid_14, uuid_13, uuid_12, uuid_11, uuid_10, uuid_9, uuid_8, uuid_7, uuid_6, uuid_5, uuid_4, uuid_3, uuid_2, uuid_1, uuid_0) \
do {\
    uuid_struct[0] = uuid_0; uuid_struct[1] = uuid_1; uuid_struct[2] = uuid_2; uuid_struct[3] = uuid_3; \
        uuid_struct[4] = uuid_4; uuid_struct[5] = uuid_5; uuid_struct[6] = uuid_6; uuid_struct[7] = uuid_7; \
            uuid_struct[8] = uuid_8; uuid_struct[9] = uuid_9; uuid_struct[10] = uuid_10; uuid_struct[11] = uuid_11; \
                uuid_struct[12] = uuid_12; uuid_struct[13] = uuid_13; uuid_struct[14] = uuid_14; uuid_struct[15] = uuid_15; \
}while(0)


#define COPY_ACC_SERVICE_UUID(uuid_struct)  COPY_UUID_128(uuid_struct,0x02,0x36,0x6e,0x80, 0xcf,0x3a, 0x11,0xe1, 0x9a,0xb4, 0x00,0x02,0xa5,0xd5,0xc5,0x1b)
//#define COPY_SW_SERVICE_UUID(uuid_struct)    COPY_UUID_128(uuid_struct,0xe2,0x3e,0x78,0xa0, 0xcf,0x4a, 0x11,0xe1, 0x8f,0xfc, 0x00,0x02,0xa5,0xd5,0xc5,0x1b)
#define COPY_ACC_UUID(uuid_struct)          COPY_UUID_128(uuid_struct,0x34,0x0a,0x1b,0x80, 0xcf,0x4b, 0x11,0xe1, 0xac,0x36, 0x00,0x02,0xa5,0xd5,0xc5,0x1b)

//#define COPY_ENV_SENS_SERVICE_UUID(uuid_struct)  COPY_UUID_128(uuid_struct,0x42,0x82,0x1a,0x40, 0xe4,0x77, 0x11,0xe2, 0x82,0xd0, 0x00,0x02,0xa5,0xd5,0xc5,0x1b)
//#define COPY_TEMP_CHAR_UUID(uuid_struct)         COPY_UUID_128(uuid_struct,0xa3,0x2e,0x55,0x20, 0xe4,0x77, 0x11,0xe2, 0xa9,0xe3, 0x00,0x02,0xa5,0xd5,0xc5,0x1b)
//#define COPY_PRESS_CHAR_UUID(uuid_struct)        COPY_UUID_128(uuid_struct,0xcd,0x20,0xc4,0x80, 0xe4,0x8b, 0x11,0xe2, 0x84,0x0b, 0x00,0x02,0xa5,0xd5,0xc5,0x1b)
//#define COPY_HUMIDITY_CHAR_UUID(uuid_struct)     COPY_UUID_128(uuid_struct,0x01,0xc5,0x0b,0x60, 0xe4,0x8c, 0x11,0xe2, 0xa0,0x73, 0x00,0x02,0xa5,0xd5,0xc5,0x1b)
#define STORE_LE_16(buf, val)    ( ((buf)[0] =  (uint8_t) (val)    ) , \
                                   ((buf)[1] =  (uint8_t) (val>>8) ) )
#define COPY_BAT_SERVICE_UUID(uuid_struct)  COPY_UUID_128(uuid_struct,0x00,0x00,0x18,0x0F,0x00,0x00,0x10,0x00,0x80,0x00,0x00,0x80,0x5f,0x9b,0x34,0xfb);
#define COPY_BAT_LEVEL_UUID(uuid_struct)  COPY_UUID_128(uuid_struct,0x00,0x00,0x2a,0x19,0x00,0x00,0x10,0x00,0x80,0x00,0x00,0x80,0x5f,0x9b,0x34,0xfb)

// SWITCH service
#define COPY_SW_SERVICE_UUID(uuid_struct)  COPY_UUID_128(uuid_struct,0x0b,0x36,0x6e,0x80, 0xcf,0x3a, 0x11,0xe1, 0x9a,0xb4, 0x00,0x02,0xa5,0xd5,0xc5,0x1b)
#define COPY_SW_UUID(uuid_struct)          COPY_UUID_128(uuid_struct,0x0c,0x36,0x6e,0x80, 0xcf,0x3a, 0x11,0xe1, 0x9a,0xb4, 0x00,0x02,0xa5,0xd5,0xc5,0x1b)

void stop(void);

uint8_t ecg_new_packet[20];

uint8_t spo2_Send(uint8_t *buff);
/*
* Routine: Add_spo2_Service
* Inputs:  None
* Outputs: None
*/
uint8_t Add_sw_Service(void)
{
    uint8_t ret=0;
    uint8_t dummy[2]={0,0};

    uint8_t uuid[16];
    uint16_t uuid16;

    COPY_SW_SERVICE_UUID(uuid);
    ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 8, &swServHandle);

    COPY_sw_UUID(uuid);
    ret =  aci_gatt_add_char(swServHandle, UUID_TYPE_128, uuid, 4,
                             CHAR_PROP_WRITE|CHAR_PROP_WRITE_WITHOUT_RESP,
                             ATTR_PERMISSION_NONE,
                             GATT_NOTIFY_ATTRIBUTE_WRITE,
                             16, 1, &swCharHandle);

}

void off()
{
    power_off();
}

void stop()
{
    allowTX=0;

}

void go()
{
    allowTX=1;

}

void Attribute_Modified_CB(uint16_t Connection_handle, uint16_t Attribute_handle, uint8_t data_length, uint8_t att_data)
{
    if(Attribute_handle==accCharHandle+1){
        if(att_data==1)off();
        else  if(att_data==2)stop();
        else if(att_data==3)go();
       // Aci_Gatt_Write_Response(Connection_handle, Attribute_handle,
               // 0, 0, data_length,att_data);
    }
}

uint8_t Add_spo2_Service(void)
{
  uint8_t ret=0;
  uint8_t dummy[2]={0,0};

  uint8_t uuid[16];
  uint16_t uuid16;

  COPY_ACC_SERVICE_UUID(uuid);
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 8, &accServHandle);



/*  COPY_FREE_FALL_UUID(uuid);
  ret =  aci_gatt_add_char(accServHandle, UUID_TYPE_128, uuid, 1,
                           CHAR_PROP_NOTIFY, ATTR_PERMISSION_NONE, 0,
                           16, 0, &freeFallCharHandle);*/

  COPY_ACC_UUID(uuid);
  ret =  aci_gatt_add_char(accServHandle, UUID_TYPE_128, uuid, spo2_PACKET_SIZE,
                           CHAR_PROP_NOTIFY|CHAR_PROP_READ| CHAR_PROP_WRITE_WITHOUT_RESP|CHAR_PROP_WRITE,
                           ATTR_PERMISSION_NONE,
                           GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP|/*GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP|*/
                           GATT_NOTIFY_ATTRIBUTE_WRITE,
                           16, 0, &accCharHandle);

  uuid16 = CHAR_CLIENT_CONFIG_DESC_UUID;
  ret = aci_gatt_add_char_desc(accServHandle,
                               accCharHandle,
                               UUID_TYPE_16,
                               (uint8_t *)&uuid16,
                               (uint8_t) 2,
                               (uint8_t) 2,
                               dummy,
                               ATTR_PERMISSION_NONE,
                               ATTR_ACCESS_WRITE_REQ_ONLY,
                               GATT_NOTIFY_ATTRIBUTE_WRITE|GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,
                               16,
                               FALSE,
                               &accCharDescHandle);
  return ret;

}
/*
* Routine: GAP_ConnectionComplete_CB
* Inputs:  Connection Handle (address is not used)
* Outputs: None
*/

void GAP_ConnectionComplete_CB(uint8_t addr[6], uint16_t handle)
{
  connected = TRUE;
  connection_handle = handle;

}

/*
* Routine: GAP_DisconnectionComplete_CB
* Inputs:  None
* Outputs: None
*/
/**
 * @brief  This function is called when the peer device gets disconnected.
 * @param  None
 * @retval None
 */
void GAP_DisconnectionComplete_CB(void)
{
  connected = FALSE;
  /* Make the device connectable again. */
  set_connectable = TRUE;
  notification_enabled = FALSE;

}
/*
* Routine: Read_Request_CB
* Inputs:  handle of request
* Outputs: None
*/

void Read_Request_CB(uint16_t handle)
{
  if(handle == accCharHandle + 1){
    spo2_Send(ecg_new_packet);
  }
  if(connection_handle != 0)
    aci_gatt_allow_read(connection_handle);

}

/*
* Routine: spo2_Send
* Inputs:  unsigned byte array to send (size should be 20)
* Outputs: returns status
*/

uint8_t spo2_Send(uint8_t *buff){
    uint8_t ret=0;
   // if(!TX_Pool_Available_Flag)return 1;
    if(allowTX !=1)return 0;
    ret = aci_gatt_update_char_value(accServHandle, accCharHandle, 0, spo2_PACKET_SIZE, buff);
    if(ret==0x64){
        missedPackets++;
        TX_Pool_Available_Flag = 0;  //no space left to send
    }else TX_Pool_Available_Flag=1;
    if(bat_cntr++ == 5000){
        bat_cntr=0;
        bat_flag=1;
        if(first_connection==0)first_connection=1;
    }
    return ret;

}


uint8_t resp_Send(uint8_t *buff){
    uint8_t ret=0;
    if(allowTX != 1)return 0;
    ret = aci_gatt_update_char_value(accServHandle, accCharHandle, 0, RESP_PACKET_SIZE, buff);
    if(ret==0x64){
        TX_Pool_Available_Flag = 0;  //no space left to send
    }else TX_Pool_Available_Flag=1;
    return ret;

}

/*
* Routine: setConnectable
* Inputs:  None
* Outputs: None
*/

void setConnectable(void)
{

  const char local_name[] =  {AD_TYPE_SHORTENED_LOCAL_NAME,'S','e','n','s','e','G','u','a','r','d'};//{AD_TYPE_COMPLETE_LOCAL_NAME,'B','l','u','e','N','R','G'};

  /* disable scan response */
  hci_le_set_scan_resp_data(0,NULL);

  aci_gap_set_discoverable(ADV_IND, 0, 0, PUBLIC_ADDR, NO_WHITE_LIST_USE,
                                 sizeof(local_name), local_name, 0, NULL, 10, 10);

  TX_Pool_Available_Flag=1;

}

