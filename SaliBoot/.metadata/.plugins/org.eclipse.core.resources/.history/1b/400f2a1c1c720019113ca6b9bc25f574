//****************************************************************************
//
//File: main.c - Sali main program.
//
// Copyright (c) 2011-2016 Inovytec.  All rights reserved.
// 
// Version 0.1.0
// 01 03 2016
// 
//*****************************************************************************

int version  = 1;
int build = 205;

//#define RUN_PARTIAL_MOTOR
//#define WIP_transfer_file
//#define RUN_FAST
//#define NO_SIM
//#define NO_MGW830	
//#define NO_TOOL_CHECK
//#define NO_WALL_SWITCH
//#define DEBUG_CPU2_PRINT
#define DEBUG
#define NEW_BOARD

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include "inc/hw_nvic.h"
#include "inc/hw_flash.h"
#include "jsonmsg.h"
#include <string.h>
#include "inc/hw_adc.h"
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"
#include "driverlib/fpu.h"
#include "driverlib/sysctl.h"
#include "driverlib/rom.h"
#include "driverlib/pin_map.h"
//#include "grlib/grlib.h"
#include "utils/uartstdio.h"
#include "driverlib/gpio.h"
#include "driverlib/hibernate.h"
#include "driverlib/timer.h"
#include "inc/hw_ints.h"
#include "inc/hw_ssi.h"
#include "driverlib/interrupt.h"
#include "utils/ustdlib.h"
#include "driverlib/uart.h"
#include "driverlib/ssi.h"
#include "driverlib/i2c.h"
///#include "inc/lm4f232h5qd.h"
#include "inc/TM4C123GH6PM.h"
#include "third_party/fatfs/src/ff.h"
#include "third_party/fatfs/src/diskio.h"
#include "driverlib/adc.h"
#include "utils/ringbuf.h"
//#include "drivers/buttons.h"
#include "IQmath/IQmathLib.h"
#include "driverlib/watchdog.h"
#include "main.h"

void closeOpenFiles()
{
	if(readingWriting == true) //if we are in the middle of reading or writing to a file, we want to first close it
	{
		f_close(&g_sReadWriteFileObject1);
		readingWriting = false;
	}

#ifdef cpu2
	if(currentSoundFile != NULL) // if a sound file is open, close it first.
	{
		f_close(&g_sAudioFileObject);
		currentSoundFile = NULL;
	}

	if(log_file)
	{
		f_close(&g_sLogFileObject2);
		log_file = false;
	}
#endif
}

#ifdef cpu2

//*****************************************************************************
//
// The interrupt handler for the watchdog. This feeds the dog (so that the
// processor does not get reset).
//
//*****************************************************************************
void
WatchdogIntHandler(void)
{
    //
    // If we have been told to stop feeding the watchdog, return immediately
    // without clearing the interrupt.  This will cause the system to reset
    // next time the watchdog interrupt fires.
    //
    if(!g_bFeedWatchdog)
    {
    	if(currentSoundFile != NULL) // if a sound file is open, close it first.
    	{
    		f_close(&g_sAudioFileObject);
    		currentSoundFile = NULL;
    	}

    	if(log_file)
    	{
    		f_close(&g_sLogFileObject2);
    		log_file = false;
    	}

    	if(readingWriting == true) //if we are in the middle of reading or writing to a file, we want to first close it
    	{
    		f_close(&g_sReadWriteFileObject1);
    		readingWriting = false;
    	}

        return;
    }

    //
    // Clear the watchdog interrupt.
    //
    ROM_WatchdogIntClear(WATCHDOG0_BASE);
}


void toggle_led()
{
	GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_1 ,tog);
	tog =~tog;
}

void toggle_led_2()
{
	GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_7 ,tog2);
	tog2 =~tog2;
}

#endif

void led_on(){GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_1 ,0xff);}
void led_off(){GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_1 ,0x00);}

#ifdef cpu1
int  br_buffer[80];
int  vf_buffer[200];
char is_first_breath = true;
#else
int  br_buffer[0];
int  vf_buffer[0];
#endif

//*****************************************************************************
// Routine: void SSI_water_mark_int_cpu2(void)
// Input: none
// Output: none
// Function:
//*****************************************************************************
#ifdef cpu2
void SSI_water_mark_int_cpu2(void)
{
	SSIIntClear(SSI2_BASE,SSI_TXFF);
	int end_cyc=buffer_pointer+8;
	while(buffer_pointer<end_cyc)
	{
		sound = audio[buffer_pointer++];
		sound = sound+256*audio[buffer_pointer++];
		SSIDataPut(SSI2_BASE,sound);
		SSIDataPut(SSI2_BASE,0x00);
	}

	if (buffer_pointer==512 )
	{
		buffer_1_empty=1;
		if (EOF_buffer2)
		{
			IntDisable(INT_SSI2);
			f_close(&g_sAudioFileObject);
			currentSoundFile = NULL;
			file_close=2;
			RingBufRead(&sRingBuf, pcData,1);
			if ((RingBufUsed(&sRingBuf))>1)loudspeaker_cpu2();
		}
	}
	else if	(buffer_pointer==1024 )
	{
		buffer_pointer=0;
		buffer_2_empty=1;
		if	(EOF_buffer1)
		{
			f_close(&g_sAudioFileObject);
			currentSoundFile = NULL;
			file_close=2;
			IntDisable(INT_SSI2);
			RingBufRead(&sRingBuf, pcData,1);
			if ((RingBufUsed(&sRingBuf))>1)loudspeaker_cpu2();
		}
	}
}
#endif

//*****************************************************************************
// Routine: int read_file(char *name, char* content)
// Input: name - file name to open
//        content - a string for returning the file content
// Output: true/false, was the file opened correctly
// Function: Opens a file on the SD card.
//*****************************************************************************
int read_file(char *name, char* content)
{
	//FRESULT fresult;
	unsigned short usBytesRead;
	int index = 0;
	char c[2];

	if(readingWriting == true) //if we are in the middle of reading or writing to a file, we want to first close it
	{
		f_close(&g_sReadWriteFileObject1);
		readingWriting = false;
	}

#ifdef cpu2
	while(currentSoundFile != NULL) //if we are in the middle of sounding a sound, we want to wait
	{
	}

	if(log_file == true) //if we are currently writing to a log file on sd card 2, we want to first close the log file.
	{
		f_close(&g_sLogFileObject2);
		log_file = false;
	}
#endif

	fresult = f_open(&g_sReadWriteFileObject1, name , FA_READ);
	readingWriting = true;
	if(fresult != FR_OK) return false;

	do
	{
		fresult = f_read(&g_sReadWriteFileObject1, c, 1, &usBytesRead);
		if(fresult != FR_OK) return false;

		//we've reached the end of the file
		if(usBytesRead < 1)
		{
			break;
		}

		if(c[0] == '\r')
			content[index]  = '\0';
		else
			content[index] = c[0];

		index++;
	}while(usBytesRead != 0);//((c[0] != '\r') && (usBytesRead != 0));

	f_close(&g_sReadWriteFileObject1);
	readingWriting = false;
	return index;
}

//*****************************************************************************
// Routine: int write_to_file(char* content, char * filename)
// Input: content - a string to write to the given file name
// Output: true/false, was the file written correctly
// Function: Writes to a file on the SD card.
//*****************************************************************************
int write_to_file(char* content, char * filename, BYTE open_mode)
{
	//FRESULT fresult;
	WORD usBytesRead;
	int size = 0;
	int num = 0;

	while(content[num] != '\0')
	{
		num++;
	}
	if(num == 0) return false;

	if(readingWriting == true) //if we are in the middle of reading or writing to a file, we want to first close it
	{
		f_close(&g_sReadWriteFileObject1);
		readingWriting = false;
	}

#ifdef cpu2
	while(currentSoundFile != NULL) //if we are in the middle of sounding a sound, we want to wait
	{
	}

	if(log_file == true) //if we are currently writing to a log file on sd card 2, we want to first close the log file.
	{
		f_close(&g_sLogFileObject2);
		log_file = false;
	}
#endif

	fresult = f_open(&g_sReadWriteFileObject1, filename , open_mode);
	readingWriting = true;
	f_sync(&g_sReadWriteFileObject1);
	if(fresult != FR_OK) return false;
	size=(&g_sReadWriteFileObject1)->fsize;
	f_lseek(&g_sReadWriteFileObject1, size);
	fresult = f_write(&g_sReadWriteFileObject1, content, num, &usBytesRead);
	f_sync(&g_sReadWriteFileObject1);
	if(fresult != FR_OK) return false;
	f_close(&g_sReadWriteFileObject1);
	readingWriting = false;
	if(fresult != FR_OK) return false;

	return true;
}

#ifdef cpu2

//*****************************************************************************
// Routine:  AudioI2C_Send_cpu2(reg,data)
// Input: reg-the number of reg to put data,data-data to send
// Output: none
// Function: Sending Data by I2C
//*****************************************************************************
void AudioI2C_Send_cpu2(unsigned char reg, unsigned long data)
{
	I2CMasterSlaveAddrSet(I2C1_MASTER_BASE, SLAVE_ADDRESS, false);

	I2CMasterDataPut(I2C1_MASTER_BASE,reg);
	I2CMasterIntClear(I2C1_MASTER_BASE);
	I2CMasterControl(I2C1_MASTER_BASE, I2C_MASTER_CMD_BURST_SEND_START);
	/*while(I2CMasterBusy(I2C1_MASTER_BASE))
	{

	}*/
	while(I2CMasterIntStatus(I2C1_MASTER_BASE, false) == 0)
	{
	}

	//
	// Clear the I2C interrupt.
	//
	I2CMasterIntClear(I2C1_MASTER_BASE);
	I2CMasterDataPut(I2C1_MASTER_BASE,(unsigned long) data);
	I2CMasterControl(I2C1_MASTER_BASE, I2C_MASTER_CMD_BURST_SEND_FINISH);
	/*while(I2CMasterBusy(I2C1_MASTER_BASE))
	{

	}*/
	while(I2CMasterIntStatus(I2C1_MASTER_BASE, false) == 0)
	{
	}

	//
	// Clear the I2C interrupt.
	//
	I2CMasterIntClear(I2C1_MASTER_BASE);
}

//*****************************************************************************
// Routine:  AudioI2C_Get_cpu2(reg)
// Input: reg-the number of reg to get data
// Output: none
// Function: Getting Data by I2C
//*****************************************************************************
char AudioI2C_Get_cpu2(unsigned char reg)
{
	long data;
	I2CMasterSlaveAddrSet(I2C1_MASTER_BASE, SLAVE_ADDRESS, false);

	I2CMasterDataPut(I2C1_MASTER_BASE,(unsigned long) reg);//4
	I2CMasterControl(I2C1_MASTER_BASE, I2C_MASTER_CMD_SINGLE_SEND);
	while(I2CMasterIntStatus(I2C1_MASTER_BASE, false) == 0){}
	I2CMasterIntClear(I2C1_MASTER_BASE);

	I2CMasterSlaveAddrSet(I2C1_MASTER_BASE, SLAVE_ADDRESS, true);
	I2CMasterControl(I2C1_MASTER_BASE, I2C_MASTER_CMD_SINGLE_RECEIVE);
	while(I2CMasterIntStatus(I2C1_MASTER_BASE, false) == 0){}
	I2CMasterIntClear(I2C1_MASTER_BASE);
	data=I2CMasterDataGet(I2C1_MASTER_BASE);

	I2CMasterIntClear(I2C1_MASTER_BASE);
	return (char)data&0xff;
}

//*****************************************************************************************************************************
// Routine:  TrimSpaces(char * *pointerToString)
// Input:  1) pointerToString - pointer to pointer of string
// Output: char * - returns the trimmed string
// Function: Trims leading and trailing spaces in a string.
//*****************************************************************************************************************************
char *TrimSpaces(char **pointerToString)
{
	int start=0, length=0;

	// Trim.Start:
	length = strlen(*pointerToString);
	while ((*pointerToString)[start]==' ') start++;
	(*pointerToString) += start;

	if (start < length) // Required for empty (ex. "    ") input
	{
		// Trim.End:
		int end = strlen(*pointerToString)-1; // Get string length again (after Trim.Start)
		while ((*pointerToString)[end]==' ') end--;
		(*pointerToString)[end+1] = 0;
	}

	return *pointerToString;
}

//*****************************************************************************************************************************
// Routine:  get_next_word(char *full_string, int index, char *pword, int final_index)
// Input: 1) full_string - string from which we want to get the relevant word,
//		  2) index - index from where to start checking for relevant word
//		  3) pword - string into which word will be inserted
//        4) final_index - index of the end of the full_string
// Output: int - place of index after word in the full_string, if word not found return 0
// Function: tries to get the next word from the string from the specified index.
//*****************************************************************************************************************************
int get_next_word(char *full_string, int index, char *pword, int final_index, bool withHyphen)
{
	int new_index;
	int k;

	if(withHyphen)
	{
		new_index = strcspn(&full_string[index], "\r\n");
	}
	else
	{
		new_index = strcspn(&full_string[index], "\r\n -");
	}

	while(!new_index && (index < final_index))
	{
		if(withHyphen)
		{
			new_index = strcspn(&full_string[index], "\r\n");
		}
		else
		{
			new_index = strcspn(&full_string[index], "\r\n -");
		}


		if(!new_index)
		{
			index++;
		}
	}

	if(index >= final_index)
	{
		return 0;
	}

	for(k = 0 ; k < 40; k++)
	{
		pword[k] = 0;
	}

	strncpy(pword, &full_string[index], new_index);
	index += new_index;

	return index;
}

//*****************************************************************************************************************************
// Routine:  get_next_apn(char *full_string, char *current_apn)
// Input:   1) full_string - string from which we want to get the apn
//			2) index - index from where to start checking for relevant word
//          3) final_index - index of the end of the full_string
//			4) current_apn - current apn (NULL if we haven't started yet)
//			5) next_apn - next apn (NULL  if there isn't another one)
// Output: int - return the new index place., if we're finished with the file return -1.
// Function: tries to get the next apn from a given string.
//*****************************************************************************************************************************
int get_next_apn(char *full_string, int index, int final_index, char *current_apn, char *next_apn)
{
	static int new_place;

	new_place = get_next_word(full_string, index, &next_apn[0], final_index,1);

	if(!new_place) //no more words
	{
		return -1;
	}

	index = new_place;

	TrimSpaces(&next_apn);

	while(!strcmp(&next_apn[strlen(next_apn) - 1], "-"))
	{
		new_place = get_next_word(full_string, index, &next_apn[0], final_index,1);
		index = new_place;

		TrimSpaces(&next_apn);
	}

	return index;
}

//*****************************************************************************************************************************
// Routine:  get_country(char *full_string, int index, char *pword, int final_index)
// Input: 1) full_string - string from which we want to get the name of the country
//		  2) index - index from where to start checking for the country name
//		  3) pword - string into which country name will be inserted
//        4) final_index - index of the end of the full_string
// Output: int - place of index after the country name in the full_string, if name not found return 0
// Function: tries to get the country name from the string from the specified index.
//*****************************************************************************************************************************
int get_country(char *full_string, int index, char *pword, int final_index)
{
	int index_result = 0;
	int new_place;
	int k;

	do
	{
		new_place = get_next_word(full_string, index, &pword[0], final_index, 0);
		index = new_place;
	}while(strcmp(pword,"Country:") || index >= final_index);

	if(!strcmp(pword,"Country:"))
	{
		for(k = 0 ; k < 20; k++)
		{
			nw_country[k] = 0;
		}

		new_place = get_next_word(full_string, index, &nw_country[0], final_index, 0);

		if(new_place)
		{
			index_result = new_place;
		}
	}

	return index_result;
}

//***********************************************************************************************************************************
// Routine:  get_service_provider(char *full_string, int index, char *pword, int final_index)
// Input: 1) full_string - string from which we want to get the name of the service provider,
//		  2) index - index from where to start checking for the service provider name
//		  3) pword - string into which the service provider name will be inserted
//        4) final_index - index of the end of the full_string
// Output: int - place of index after the service provider name in the full_string, if  service provider name not found, return 0
// Function: tries to get the service provider name from the string from the specified index.
//***********************************************************************************************************************************
int get_service_provider(char *full_string, int index, char *pword, int final_index)
{
	int index_result = 0;
	int new_place;
	int k;

	do
	{
		new_place = get_next_word(full_string, index, &pword[0], final_index, 0);
		index = new_place;
	}while(strcmp(pword,"Service_Provider:") || index >= final_index);

	if(!strcmp(pword,"Service_Provider:"))
	{
		for(k = 0 ; k < 20; k++)
		{
			service_provider[k] = 0;
		}

		new_place = get_next_word(full_string, index, &service_provider[0], final_index, 0);

		if(new_place)
		{
			index_result = new_place;
		}
	}

	return index_result;
}

//*****************************************************************************************************************************
// Routine:  get_apn_name(char *full_string, int final_index)
// Input:  1) full_string - string from which we want to get the name of the service provider, according to the service_provider.
//         2) final_index - index of the end of the full_string.
// Output: boolean true/false
// Function: Tries to get a specific apn according to country and service provider.
//*****************************************************************************************************************************
bool get_apn_name(char *full_string, int final_index)
{
	bool apn_found = false;
	int new_place;
	int k;
	int index = 0;

	do
	{
		new_place = get_next_word(full_string, index, &chosen_apn[0], final_index, 0);
		index = new_place;
	}while(strcmp(chosen_apn,service_provider) || index >= final_index);

	if(!strcmp(chosen_apn,service_provider))
	{
		for(k = 0 ; k < 40; k++)
		{
			chosen_apn[k] = 0;
		}

		new_place = get_next_word(full_string, index, &chosen_apn[0], final_index, 0);

		if(new_place)
		{
			apn_found = true;
		}
	}

	return apn_found;
}

//*****************************************************************************************************************************
// Routine:  get_apn_by_name()
// Input:  none
// Output: boolean true/false
// Function: Tries to get a specific apn according to country and service provider.
//*****************************************************************************************************************************
bool get_apn_by_name()
{
	int k;
	bool apn_found = false;

	for(k = 0 ; k < 20; k++)
	{
		country_file[k] = 0;
	}

	if(!strcmp(nw_country, "China"))
	{
		strcpy(country_file, "APNS/ch_apn.txt");
	}
	else if(!strcmp(nw_country, "Germany"))
	{
		strcpy(country_file, "APNS/de_apn.txt");
	}
	else if(!strcmp(nw_country, "Israel"))
	{
		strcpy(country_file, "APNS/il_apn.txt");
	}
	else if(!strcmp(nw_country, "Usa"))
	{
		strcpy(country_file, "APNS/us_apn.txt");
	}
	else if(!strcmp(nw_country, "Cyprus"))
	{
		strcpy(country_file, "APNS/cy_apn.txt");
	}
	else //we didn't find the relevant file
	{
		return apn_found;
	}

	for(k = 0 ; k < 700; k++)
	{
		read_nw_dets[k] = 0;
	}

	nw_choice_len = read_file(country_file, read_nw_dets);

	if(nw_choice_len)
	{
		if(get_apn_name(read_nw_dets, nw_choice_len))
		{
			apn_found = true;
		}
	}

	return apn_found;
}

//*****************************************************************************************************************************
// Routine:  get_chosen_apns()
// Input: none
// Output: boolean true/false
// Function: tries to read a file with data regarding relevant country and cell network,
//			 from which we try to find the relevant apn to connect to so as not to try all of the apns we have.
//*****************************************************************************************************************************
bool get_chosen_apns()
{
	int k;
	bool apn_status = false;

	for(k = 0 ; k < 50; k++)
	{
		read_nw_dets[k] = 0;
	}

	int nw_choice_len = read_file("nwchoice.txt", read_nw_dets);

	//if we read a file detailing the network choice,
	//this is intended in order to try to get a relevant apn right away instead of going through the whole list.
	if(nw_choice_len)
	{
		char pword[40];
		int place;
		int new_place;

		place = 0;

		new_place = get_country(read_nw_dets, place, &pword[0], nw_choice_len);

		if(new_place) //if we were succesfull in getting a country name
		{
			place = new_place;

			new_place = get_service_provider(read_nw_dets, place, &pword[0], nw_choice_len);

			if(new_place) //if we were succesfull in getting a service_provider name
			{
				if(get_apn_by_name())
				{
					apn_status = 1;
				}
			}
		}
	}
	return apn_status;
}

//****************************************************************************************************************
// Routine:  checkCallStatus()
// Input: none
// Output: none
// Function: check status of incoming call, and decide accordingly if to connect or disconnect speaker to modem
//****************************************************************************************************************
bool checkCallStatus()
{
	char callStatusResp[100];
	int size;
	int ret=0;
	bool cont=true;

	Sending_message == true;

	UARTprintf("AT+CLCC\r");

	Sending_message == false;

	while(ret != 1)
	{
		if(ret == 1) //returned "OK"
		{
			cont = TRUE;
		}

		if(ret == -1) //returned "ERROR"
		{
			return FALSE;
		}

		//we got a call...
		if((ret == 2) && (callStatusResp[1] == 'C') && (callStatusResp[2] == 'L') && (callStatusResp[13] == '0') &&
		   (door_status == 1) && (shouldHearCaller == true))
		{
			AudioI2C_Send_cpu2(0,0x01); //move to page 1
			AudioI2C_Send_cpu2(35,0x60); //Connect modem to speaker.
			AudioI2C_Send_cpu2(0,0x00); //return to page 0
			cont = FALSE;

			if(!callInProgress)
			{
				callInProgress = 1;
				sendData = 1;
			}
		}
		else if((ret == 2) && (callStatusResp[2] == 'M') && ( callStatusResp[3]== 'E')) //we got an error message.
		{
			cont = FALSE;
		}
		else if((ret == 2) && (callStatusResp[13] == '0') && (callInProgress == 1)) // already in the middle of a call
		{
			cont = FALSE;
		}
		else if(ret == -2)
		{
			return FALSE; //no need to wait... this shouldn't happen
		}

		ret = getStrings(callStatusResp,&size,5);
	}

	if(!cont)return TRUE;

	if((callInProgress == 1) && (file_close == 2)) //We had a call, but not anymore in addition we aren't in the middle of sounding a sali sound.
	{
		AudioI2C_Send_cpu2(0,0x01); //move to page 1
		AudioI2C_Send_cpu2(35,0x40); //Disconnect modem from speaker.
		AudioI2C_Send_cpu2(0,0x00); //return to page 0
		callInProgress = 0;

		play_audio_cpu2 = 0x1D;
	}
	return TRUE;
}

//************************************************************************************************
// Routine:  callEmergencyCenter(char *Emergency_Num)
// Input: none
// Output: none
// Function: try to call the emergency center in the area according to number read from sd card.
//************************************************************************************************
void callEmergencyCenter(char *Emergency_Num)
{
	int k;
	char callResponse[20];

	for (k=0; k<20;k++){callResponse[k]=0;}

	UARTFlushRx();
	usprintf(str,"ATD%s;\r", Emergency_Num);
	UARTprintf(str);

	while((callResponse[0] != 'O')  &&  (callResponse[1] != 'K'))
	{
		UARTgets(callResponse, 3);
	}

	call_activated = 1;
}

//************************************************************************************************
// Routine:  disconnectCall()
// Input: none
// Output: none
// Function: disconnect the emergency center call
//************************************************************************************************
void disconnectCall()
{
	int k;
	char disconnectResponse[30];
	int ret=0;
	int retry = 0;
	int size;

	for (k=0; k<30;k++){disconnectResponse[k]=0;}

	UARTFlushRx();
	UARTprintf("AT+CHUP\r");

	while(ret != 1)
	{
		if(ret == 2); //This is an unexpected result... in the future decide what to do.
		if(ret == -2); //This shouldn't happen maybe problem with modem

		if(ret == -1)
		{
			UARTprintf("AT+CHUP\r"); // This also should not happen means command wasn't sent properly
		}

		if(retry++ == 3)return;  //try later

		ret = getStrings(disconnectResponse,&size,10);
	}

	AudioI2C_Send_cpu2(0,0x01); //move to page 1
	AudioI2C_Send_cpu2(35,0x40); //Disconnect modem from speaker.
	AudioI2C_Send_cpu2(0,0x00); //return to page 0
	callInProgress = 0;

	play_audio_cpu2 = 0x1D;
}
#endif

typedef struct
{
	FRESULT fresult;
	// char *pcResultStr;
}
tFresultString;

//*****************************************************************************
//
//  Tick Handler
//
//*****************************************************************************
void SysTickHandler(void)
{
	//
	// Call the FatFs tick timer.
	//
	disk_timerproc();
}

//*****************************************************************************
//
// The error routine that is called if the driver library encounters an error.
//
//*****************************************************************************
#ifdef DEBUG
void __error__(char *pcFilename, unsigned long ulLine)
{
}
#endif

//*****************************************************************************
// Routine: RTCMATCHIntHandler(void)
// Input: none
// Output: none
// Function: Interrupt from the RTC in order to wake up
//*****************************************************************************
void RTCMATCHIntHandler(void)
{
	unsigned long ulStatus;

	// Clear the RTC interrupts (this can be slow for hib module)
	ulStatus = HibernateIntStatus(1);
	HibernateIntClear(ulStatus);
	ROM_UARTCharPut(UART0_BASE,0x0a);
	while(1)
	{
		ROM_UARTCharPut(UART0_BASE,0x0b);
		//ROM_UARTCharPut(UART0_BASE,0x0a);
	}
	/*
	ROM_UARTCharPut(UART0_BASE,0x0c);
	if(ulStatus & HIBERNATE_INT_PIN_WAKE)
	{
		reset1=wake;
	}
	// HibernateIntClear(ulStatus);
	//
	// Read and save the current value of the seconds counter.
	//
	//waking for selftest only if we are not already working
	if(reset1!=wake)
	{
		reset1=self_test;
	}
	// Read and save the current value of the seconds counter.
	// ulSeconds = HibernateRTCGet();
	// ulSeconds+=10;
	//  HibernateRTCMatch0Set(ulSeconds);//adding 10 sec for the next wake up
	 */
}

//*****************************************************************************
// Routine: computeTci(int Nold, int t1,int t2, int t3, int t4
// Input: Nold-count the complex,t1-prev fall time,t2-prev rise time,t3-next fall time,t4-next rise time
// Output: none
// Function: Computing time counting algorthim
//*****************************************************************************
#ifdef cpu1
void computeTci(int Nold, int t1,int t2, int t3, int t4)
{ 
	int tci=0;
	int Tim1;

	int Tim2;

	VF_Detected = false;

	if(Nold>2)
	{
		if((t1+t2)==0)
			Tim1=0;
		else
			Tim1=((10*t2)/(t1+t2));
		if((t3+t4)==0)
			Tim2=0;
		else
			Tim2=((10*t3)/(t3+t4));
		tci=10000/((10*(Nold-1))+Tim1+Tim2);


		if(tci<400)
		{
			if (0)//FirstAED)
			{
				FirstAED=false;
				//events[1]=true;
				state1 = AED_STATE_PRESS_GREEN;
				ValidCheckSumFromAED=true;
			}
			VF_Detected = true;
		}
	}
}
#endif

#ifdef cpu2

//*****************************************************************************
// Routine: void saving_log(char content[])
// Input: name-string to save
// Output: none
// Function: Saving log file on the sd card
//*****************************************************************************
void saving_log(char content[])
{  
	int size;
	int num = 0;
	char time_stamp[70];

	usprintf(time_stamp,"[%02d/%02d/%02d  %02d:%02d:%02d]: ",curr_day,curr_month,curr_year,curr_hour,curr_minute,curr_sec);
	strcat(time_stamp, content);
	strcat(time_stamp, "\r");

	while(time_stamp[num] != '\0')
	{
		num++;		
	}

	if(readingWriting == true) //if we are in the middle of reading or writing to a file, we want to first close it
	{
		f_close(&g_sReadWriteFileObject1);
		readingWriting = false;
	}

	while(currentSoundFile != NULL) //if we are in the middle of sounding a sound, we want to wait
	{
	}

	if(log_file == true) //if we are currently writing to a log file on sd card 2, we want to first close the log file.
	{
		f_close(&g_sLogFileObject2);
		log_file = false;
	}

	fresult = f_open(&g_sLogFileObject2, "log.txt" , FA_WRITE | FA_OPEN_ALWAYS );
	log_file = true;
	f_sync(&g_sLogFileObject2);

	size=(&g_sLogFileObject2)->fsize;
	f_lseek(&g_sLogFileObject2, size);

	fresult = f_write(&g_sLogFileObject2, time_stamp, num, &usBytesRead);
	f_sync(&g_sLogFileObject2);

	//if(fresult != FR_OK)
	if (fresult || usBytesRead<num)
	{   
		UARTprintf("%d",fresult);
	}
	f_close(&g_sLogFileObject2);
	log_file = false;
}
#endif

#ifdef cpu1
//*****************************************************************************
// Routine: int write_log(char* content)
// Input: content - a string for write to the log file     
// Output: true/false, was the file written correctly
// Function: Writes to a log file on the SD card.
//*****************************************************************************
int write_log(char* content)
{
	//FRESULT fresult;
	unsigned short usBytesRead;
	int size = 0;
	int num = 0;

	DebugPrintWithTime("Writing to log: ");
	DebugPrint(content);
	DebugPrint("\r\n");

	while(content[num] != '\0')
	{
		num++;		
	}
	if(num == 0) return false;

	fresult = f_open(&g_sReadWriteFileObject1, log_filename , FA_WRITE | FA_OPEN_ALWAYS);
	f_sync(&g_sReadWriteFileObject1);

	if(fresult != FR_OK) return false;
	size=(&g_sReadWriteFileObject1)->fsize;
	f_lseek(&g_sReadWriteFileObject1, size);
	fresult = f_write(&g_sReadWriteFileObject1, content, num, &usBytesRead);
	f_sync(&g_sReadWriteFileObject1);

	if(fresult != FR_OK) return false;
	f_close(&g_sReadWriteFileObject1);
	if(fresult != FR_OK) return false;

	return true;
}
#endif

//*****************************************************************************
// Routine: InitRingBuffers()
// Input: none
// Output: none
// Function: initialize ring buffers
//*****************************************************************************
void InitRingBuffers()
{
	Buf1_flag = 0;
	Buf2_flag = 0;
	Buf3_flag = 0;
	Buf4_flag = 0;
	Buf5_flag = 0;

	RingBufInit(&RingBuf1, passBuffer1, sizeof(passBuffer1));
	RingBufInit(&RingBuf2, passBuffer2, sizeof(passBuffer2));
	RingBufInit(&RingBuf3, passBuffer3, sizeof(passBuffer3));
	RingBufInit(&RingBuf4, passBuffer4, sizeof(passBuffer4));
	RingBufInit(&RingBuf5, passBuffer5, sizeof(passBuffer5));
}

#ifdef cpu1
//*****************************************************************************
// Routine: void Send_To_Comm_Port(int dest, unsigned long usedBufLength)
// Input: dest - destination cpu, usedBufLength - buffer length to send.
// Output: none
// Function: sends data from cpu1 to destination cpu.
//*****************************************************************************
void Send_To_Comm_Port(int dest, unsigned long usedBufLength)
{
	int i;

	switch(dest)
	{
	case 2:
		for(i = 0; i < usedBufLength; i++)
		{
			SSIDataPut(SSI3_BASE,pcData[i]);
		}
		break;
	case 3:
		for(i = 0; i < usedBufLength; i++)
		{
			ROM_UARTCharPut(UART5_BASE,pcData[i]);
		}
		break;
	default:
		break;
	}
}

//*****************************************************************************
// Routine: void Send_from_cpu1(int dest)
// Input: dest - destination cpu
// Output: none
// Function: Reads data from ringbuffers and sends the data from cpu1 to destination cpu.
//*****************************************************************************
void Send_from_cpu1(int dest)
{
	static unsigned long usedBufLength = 0;

	if(Buf1_flag == 2)
	{
		usedBufLength = RingBufUsed(&RingBuf1);
		RingBufRead(&RingBuf1, pcData,usedBufLength);

		Send_To_Comm_Port(dest,usedBufLength);

		Buf1_flag = 0;
	}

	if(Buf2_flag == 2)
	{
		usedBufLength = RingBufUsed(&RingBuf2);
		RingBufRead(&RingBuf2, pcData,usedBufLength);

		Send_To_Comm_Port(dest,usedBufLength);

		Buf2_flag = 0;
	}

	if(Buf3_flag == 2)
	{
		usedBufLength = RingBufUsed(&RingBuf3);
		RingBufRead(&RingBuf3, pcData,usedBufLength);

		Send_To_Comm_Port(dest,usedBufLength);

		Buf3_flag = 0;
	}

	if(Buf4_flag == 2)
	{
		usedBufLength = RingBufUsed(&RingBuf4);
		RingBufRead(&RingBuf4, pcData,usedBufLength);

		Send_To_Comm_Port(dest,usedBufLength);

		Buf4_flag = 0;
	}

	if(Buf5_flag == 2)
	{
		usedBufLength = RingBufUsed(&RingBuf5);
		RingBufRead(&RingBuf5, pcData,usedBufLength);

		Send_To_Comm_Port(dest,usedBufLength);

		Buf5_flag = 0;
	}
}

//*****************************************************************************
// Routine: Write_To_RingBuffer(int dest_cpu, unsigned char *pucData, unsigned long ulLength)
// Input: dest - destination cpu, pucData - pointer to char array from which to read the data, ulLength - buffer length to write.
// Output: none
// Function: writing to a ring buffer and sending the data on to destination cpu.
//*****************************************************************************
void Write_To_RingBuffer(int dest_cpu, unsigned char *pucData, unsigned long ulLength)
{
	//find and use an empty ring buffer
	if(!Buf1_flag)
	{
		Buf1_flag = 1;
		RingBufWrite(&RingBuf1, pucData, ulLength);
		Buf1_flag = 2;
	}
	else if(!Buf2_flag)
	{
		Buf2_flag = 1;
		RingBufWrite(&RingBuf2, pucData, ulLength);
		Buf2_flag = 2;
	}
	else if(!Buf3_flag)
	{
		Buf3_flag = 1;
		RingBufWrite(&RingBuf3, pucData, ulLength);
		Buf3_flag = 2;
	}
	else if(!Buf4_flag)
	{
		Buf4_flag = 1;
		RingBufWrite(&RingBuf4, pucData, ulLength);
		Buf4_flag = 2;
	}
	else if(!Buf5_flag)
	{
		Buf5_flag = 1;
		RingBufWrite(&RingBuf5, pucData, ulLength);
		Buf5_flag = 2;
	}
	else
	{
		//we're in trouble!!! no empty ringbuffer to write into.
		return;
	}

	switch(dest_cpu)
	{
	case 2: //send from cpu1 to cpu2
		Send_from_cpu1(2);
		break;

	case 3: //send from cpu1 to cpu3
		Send_from_cpu1(3);
		break;

	default:
		break;
	}
}

void send_langauges()
{
	// Send language to cpu2 and cpu3
	DebugPrintWithTime("Send language to cpu2 and cpu3\r\n");

	unsigned char language[5] = {0xBB, lang_a[0], lang_a[1], lang_b[0], lang_b[1]};

	Write_To_RingBuffer(2, language, 5);

	language[0] = 0xf3;
	Write_To_RingBuffer(3, language, 5);
}

//*****************************************************************************
// Routine: switch_decoder2_cpu1(void)
// Input: none
// Output: none
// Function: Checking the door state
//*****************************************************************************
void switch_decoder2_cpu1(void)
{
	//check if door is open Port E pin 6
	// door open switch is a high with wall mount is open and a low when door is closed
	// check for 5 consecutive values in same state to determine real switch value
	//
	input = GPIOPinRead(GPIO_PORTE_BASE, GPIO_PIN_6);		 //get value
	//ROM_UARTCharPut(UART0_BASE,input&0xff);

	if((input & GPIO_PIN_6) == GPIO_PIN_6)
	{
		new_wall_state = CLOSE;  //you may need to switch
	}
	else
	{
		new_wall_state = OPEN;
	}

	if((new_wall_state != wall_state) && (wall_cntr > 0))
	{
		wall_cntr=wall_cntr-1;

		if(wall_cntr == 0)
		{	
			wall_state = new_wall_state;

			if(wall_state == OPEN)
			{
				log_message("Put on wall mount.");
				sali_on_mount = true;

				unsigned char on_wall_mount[1]={0x49};
				Write_To_RingBuffer(2, on_wall_mount, 1);
				GPIOIntTypeSet(GPIO_PORTE_BASE,GPIO_PIN_6 , GPIO_HIGH_LEVEL);
			}
			else 
			{
				log_message("Taken off wall mount.");
				sali_on_mount = false;

				unsigned char off_wall_mount[1]={0x48};
				Write_To_RingBuffer(2, off_wall_mount, 1);

				GPIOIntTypeSet(GPIO_PORTE_BASE,GPIO_PIN_6 , GPIO_LOW_LEVEL);
			}
		}
	}
	else
	{
		wall_cntr=1000;
	}
}

//*****************************************************************************
// Routine: switch_decoder_cpu1(void)
// Input: none
// Output: none
// Function: Checking the door state
//*****************************************************************************
void switch_decoder_cpu1(void)
{
	//check if door is open Port E pin 7
	// door open switch is a high with door is open and a low when door is closed
	// check for 5 consecutive values in same state to determine real switch value
	//
	input = GPIOPinRead(GPIO_PORTE_BASE, GPIO_PIN_7);		 //get value
	//ROM_UARTCharPut(UART0_BASE,input&0xff);
	if((input&GPIO_PIN_7)==GPIO_PIN_7) new_door_state = OPEN;  //you may need to switch
	else new_door_state = CLOSE;

	//ROM_UARTCharPut(UART0_BASE,new_door_state+48);
	//ROM_UARTCharPut(UART0_BASE,door_state+48);

	if((new_door_state != door_state)&&(door_cntr > 0))
	{
		door_cntr=door_cntr-1;

		if(door_cntr == 0)
		{	
			door_state = new_door_state;
			if(door_state == OPEN)
			{
				log_message("Door opened.");
				Standby15Minutes = false;
				GPIOIntTypeSet(GPIO_PORTE_BASE,GPIO_PIN_7 , GPIO_LOW_LEVEL);

				//re-enable the interrupts from the m101
				UARTEnable(UART3_BASE);
			}
			else 
			{
				Standby15Minutes = true;
				wake_after_self_test = false;
				log_message("Door Closed.");
				GPIOIntTypeSet(GPIO_PORTE_BASE,GPIO_PIN_7 , GPIO_HIGH_LEVEL);

				//disable the interrupts from the m101
				UARTDisable(UART3_BASE);

				// Closing two Oxygen Solenoids
				GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_1 ,oxygen_level[0][0]);
				GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_2 ,oxygen_level[0][1]);
			}
		}
	}
	else door_cntr=200000;
}
#endif

#ifdef cpu2
//*****************************************************************************
// Routine: switch_decoder_cpu2(void)
// Input: none
// Output: none
// Function: Checking the ADVANCE button state
//*****************************************************************************
void switch_decoder_adv_cpu2(void)
{
	//check if the button is pushed in Port H pin 0
	// button advance switch is a high with button not pushed is open and a low when the button is pushed
	// check for 5 consecutive values in same state to determine real switch value
	//
	input = GPIOPinRead(GPIO_PORTH_BASE, GPIO_PIN_0);		 //get value
	if((input&GPIO_PIN_0)==0) new_button_state = OPEN;  //you may need to switch
	else new_button_state = CLOSE;

	if((new_button_state != button_state)&&(button_cntr > 0))
	{
		button_cntr=button_cntr-1;
		if(button_cntr == 0)
		{	 
			button_state = new_button_state;

			if(button_state == OPEN)
			{ 
				ROM_UARTCharPut(UART2_BASE,0x04);
				ROM_UARTCharPut(UART2_BASE,button_state);

				advanced_press_timer = 0;
				run_advanced_timer = 1;
			}
			if(button_state == CLOSE)
			{ 
				ROM_UARTCharPut(UART2_BASE,0x04);
				ROM_UARTCharPut(UART2_BASE,button_state);

				if(advanced_press_timer >= 1200)
				{
					EmergencyCallRequested = 1;
				}

				advanced_press_timer = 0;
				run_advanced_timer = 0;
			}
		}
	}
	else button_cntr=50;
}
//*****************************************************************************
// Routine: switch_decoder_cpu21(void)
// Input: none
// Output: none
// Function: Checking the LANG button state
//*****************************************************************************
void switch_decoder_adv_cpu21(void)
{
	//check if Lang button is pushed on Port H pin 1
	// button lang  is a high with button is not pushed and a low when the button is pushed
	// check for 5 consecutive values in same state to determine real switch value
	//
	input1= GPIOPinRead(GPIO_PORTH_BASE, GPIO_PIN_1);		 //get value
	if((input1&GPIO_PIN_1)==0) new_button_state1 = OPEN;  //you may need to switch
	else new_button_state1 = CLOSE;

	if((new_button_state1 != button_state1)&&(button_cntr1 > 0))
	{
		button_cntr1=button_cntr1-1;
		if(button_cntr1 == 0)
		{	 
			button_state1 = new_button_state1;

			if(button_state1 == OPEN)
			{ 
				ROM_UARTCharPut(UART2_BASE,0x05);
				ROM_UARTCharPut(UART2_BASE,button_state1);

				rel1=0;
			}
			if(button_state1 == CLOSE)
			{
				ROM_UARTCharPut(UART2_BASE,0x05);
				ROM_UARTCharPut(UART2_BASE,button_state1);

				lang_ch1=1;
				if((lang_ch1)&&(rel1==0))
				{
					rel1=1;
					lang_ch1=0;
					if(!(lang))
					{
						lang=1;
					}
					else
					{
						lang=0;
					}
				}

				rel1=0;
			}
		}
	}
	else button_cntr1=10;
}
//*****************************************************************************
// Routine: switch_decoder_cpu22(void)
// Input: none
// Output: none
// Function: Checking the Green button
//*****************************************************************************
void switch_decoder_adv_cpu22(void)
{
	//check if Lang button is pushed on Port H pin 1
	// button lang  is a high with button is not pushed and a low when the button is pushed
	// check for 5 consecutive values in same state to determine real switch value
	//
	input2 = GPIOPinRead(GPIO_PORTH_BASE, GPIO_PIN_2);		 //get value

	if((input2&GPIO_PIN_2)==0) new_button_state2 = OPEN;  //you may need to switch
	else new_button_state2 = CLOSE;

	if((new_button_state2 != button_state2)&&(button_cntr2 > 0))
	{
		button_cntr2=button_cntr2-1;
		if(button_cntr2 == 0)
		{	 
			button_state2 = new_button_state2;
			if(button_state2 == OPEN)
			{ 
				// turn green light on
				isGreenButtonLEDOn = true;
				led_on();
			}
			if(button_state2 == CLOSE)
			{ 
				led_off();
				isGreenButtonLEDOn = false;
				ROM_UARTCharPut(UART2_BASE,0x07);
				ROM_UARTCharPut(UART2_BASE,button_state2);
				///rel1=0;
			}
		}
	}
	else button_cntr2=5;
}	
#endif

#ifdef cpu1
//array of 4 X 2 with 4 opption for 2 bit so level 0 to 3
//*****************************************************************************
// Routine: check_update_oxygen_level
// Input: none
// Output: none
// Function: Updating oxygen level
//*****************************************************************************	
void check_update_oxygen_level()			
{	///static int level;
	if ((level>=0) &&(level<=3))
	{
		if ((spo2value>1) && (spo2value<20))
			level--;
		else if	((spo2value>=20) && (spo2value<24))
			level++;
		else if	(spo2value==0) 
			level++;
	}
	GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_1 ,oxygen_level[level][0]);
	GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_2 ,oxygen_level[level][1]);
}	
#endif

//*****************************************************************************
// Routine: isStatePressGreen
// Input: int state
// Output: int ret 
// Function: return true if the state given is a press green state
//*****************************************************************************	
int isStatePressGreen(int state)
{
	int ret = 0;
	if(state == SYSTEM_STATE_PRESS_GREEN_IF_NO_RESPONSE || state == SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN)
		ret = 1;

	return ret;
}

#ifdef cpu1
void handleBackdoor(int input, int prev_input)
{
	static int lang_unpressed = false;
	//DebugPrint("in handleBackdoor ");
	if(prev_input == 4)
	{
		if(input == 1)
		{
			adv_pressed = true;
			//DebugPrint("adv_pressed = true ");
		}
		else
		{
			adv_pressed = false;
			//DebugPrint("adv_pressed = false ");
		}
	}
	if(prev_input == 5)
	{
		if(input == 1)
		{
			lang_pressed = true;
			//DebugPrint("lang_pressed = true ");
		}
		else
		{
			lang_pressed = false;
			lang_unpressed = true;
			//DebugPrint("lang_pressed = false ");
		}
	}

	if(system_state == SYSTEM_STATE_PLACE_HEAD_ON_HEADREST && adv_pressed && lang_pressed)
	{
		DebugPrint("enter backdoor 1");
		log_message("Enter backdoor screen.");

		system_state = SYSTEM_STATE_BACKDOOR1;
		lang_unpressed = false;
	}
	else if(system_state == SYSTEM_STATE_BACKDOOR1 && lang_pressed && lang_unpressed)
	{
		DebugPrint("enter backdoor 2");
		system_state = SYSTEM_STATE_BACKDOOR2;
		lang_unpressed = false;
	}
	else if(system_state == SYSTEM_STATE_BACKDOOR2 && lang_pressed && lang_unpressed)
	{
		DebugPrint("exit backdoor");
		log_message("Exit backdoor screen.");
		system_state = SYSTEM_STATE_PLACE_HEAD_ON_HEADREST;
		lang_unpressed = false;
	}
}

//*****************************************************************************
// Routine: cpu2_restart_update
// Input: none
// Output: none
// Function: update cpu2 with data from cpu1 when cpu2 has been reset.
//*****************************************************************************
void cpu2_restart_update(void)
{
	send_langauges();

	//if we are currently working with backup language, need to update cpu2
	if(prlan == 0)
	{
		unsigned char backup_lang[1] = {0xBD};
		Write_To_RingBuffer(2, backup_lang, 1);
	}

	if(door_state == OPEN)
	{
		//sending cpu2 that the door is open
		unsigned char door_open[1] = {0x86};
		Write_To_RingBuffer(2, door_open, 1);
	}
	else
	{
		//sending cpu2 that we are in mute status, since the door is closed
		unsigned char mute_vol[2] = {0x82, 100};
		Write_To_RingBuffer(2, mute_vol, 2);
	}
}

#endif

//*****************************************************************************
// Routine: button_decode_cpu1
// Input: pullData
// Output: none
// Function: Decoding cpu2 to cpu1 communication
//*****************************************************************************	
#ifdef cpu1
void button_decode_cpu1(char pullData)
{
	static int TCNTR=0;
	long input;
	static long prev_input = -1;

	input = (long)(pullData & 0xff);

	handleBackdoor((int)input, (int)prev_input);

	usprintf(str,"pullData = %d and input = %d ",pullData,input);
	//DebugPrint(str);

	if(input == -1)return;		//error no character was available
	prev_input = input;

	if(state == WAIT_COMMAND)
	{
		switch(input)
		{
		case 0x04:
		{
			DebugPrintWithTime("Advanced pressed\r\n ");
			//Advanced pressed
			if(system_state != SYSTEM_STATE_ADVANCED_SCREEN &&
					((system_status == SYSTEM_STATUS_DEFIB && !shock_not_advised_flag) || shock_not_advised_flag ||
							(!defib_activated && system_state != SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN && system_state != SYSTEM_STATE_PRESS_GREEN_IF_NO_RESPONSE)) &&
							system_status != SYSTEM_STATUS_CPR)
			{
				if(system_state != SYSTEM_STATE_PLACE_HEAD_ON_HEADREST)
					state = adv_click;
			}
			else if(system_state == SYSTEM_STATE_ADVANCED_SCREEN)
				state = adv_click;
			break;
		}
		case 0x05:
		{
			DebugPrintWithTime("Lang Pressed\r\n ");
			// Lang Pressed, change lang if we are not getting into backdoor
			state = lang_click;
			break;
		}
		case 0xE6:
		{
			DebugPrintWithTime("Getting time\r\n ");
			state = timecpu1;
			break;
		}
		case 0x07:
		{
			DebugPrintWithTime("Activating Defibrilator\r\n ");
			state = ACTDEF;
			break;
		}
		case 0x0A:
		{
			// call the boot loader for a sofware update

			// Will not get here, reboots
			break;
		}
		case 0x0B:
		{
			DebugPrintWithTime("Get file.\r\n");
			//receive a file name.
			//state = receive_file_name;
			break;
		}
		case 0x0C:
		{
			//receive a file size.
			DebugPrintWithTime("receive file size.\r\n");
			//state = receive_file_size;
			break;
		}
		case 0x0D:
		{
			//receive a file data.
			DebugPrintWithTime("receive file data.\r\n");
			//state = receive_file_data;
			break;
		}
		case 0xEE:
		{
			log_message("Communication down.\r\n");

			if(comm_status_cpu1 == 1)
			{
				comm_status_cpu1 = 0;

				unsigned char comm_down[2] = {0x95, 0};

				Write_To_RingBuffer(3, comm_down, 2);
			}
			break;
		}
		case 0x0F:
		{
			log_message("Communication up.\r\n");

			if(comm_status_cpu1 == 0)
			{
				comm_status_cpu1 = 1;

				unsigned char comm_up[2] = {0x95, 1};

				Write_To_RingBuffer(3, comm_up, 2);
			}
			break;
		}
		case 0x10:
		{
			log_message("CPU2 was reset by watchdog!\r\n");

			cpu2_restart_update();
			break;
		}
		case 0x11:
		{
			log_message("CPU2 was reset by software!\r\n");

			cpu2_restart_update();
			break;
		}
		default:
			break;
		}
	}
	else {
		switch (state) {
		case adv_click:          ///advance_click
		{
			if(input==1)
			{
				//DebugPrint("pressed down");
				timer_adv_press = 400;
			}
			if(input==0)
			{
				//DebugPrint("pressed up");

				if(timer_adv_press == 0)
				{
					//DebugPrint("Silence!!! ");
					if(system_state == SYSTEM_STATE_CHECK_ECG_STICKERS) silence_ecg = 200 * 60 * 2;
					if(system_state == SYSTEM_STATE_CHECK_PROBE) silence_probe = 200 * 60 * 2;
					wait2 = 0;
				}
				else
				{
					if(system_state != SYSTEM_STATE_ADVANCED_SCREEN &&
							system_state != SYSTEM_STATE_BACKDOOR1 &&
							system_state != SYSTEM_STATE_BACKDOOR2 )
					{
						but_stat=0;

						if(system_status != SYSTEM_STATUS_DEFIB || shock_not_advised_flag)
						{
							//unsigned char adv_background[2] = {0x81, 0x11};
							//Write_To_RingBuffer(3, adv_background, 2);

							system_state = SYSTEM_STATE_ADVANCED_SCREEN;
							hr_sources = 0;
							log_message("Enter advanced screen.");
							DebugPrintWithTime("Entering Advanced Screen\r\n");
						}
					}
					else if(system_state == SYSTEM_STATE_ADVANCED_SCREEN)
					{
						but_stat=1;
						//prev_system_state = SYSTEM_STATE_NONE;
						saved_system_state = SYSTEM_STATE_NONE;
						system_state = SYSTEM_STATE_ALL_SENSORS_IN_PLACE;//SYSTEM_STATE_MONITORING;
						silence_probe = 0;
						silence_ecg = 0;
						MonitorStatusFlag = 0;
						log_message("Exit advanced screen.");
						DebugPrintWithTime("Exiting Advanced Screen\r\n");
					}
				}
				timer_adv_press = -1;
			}

			state = WAIT_COMMAND;
			break;
		}
		case lang_click:
		{
			if(input == 0)
			{
				lang_ch=true;
				rel=1;

				if(lang_ch)
				{
					if(!(prlan))
					{
						prlan=1;
						log_message("Language changed.\r\n");
						log_message(lang_a);
					}
					else
					{
						prlan=0;
						log_message("Language changed.\r\n");
						log_message(lang_b);
					}

					unsigned char change_language[2] = {0xf2, prlan};
					Write_To_RingBuffer(3, change_language, 2);

					change_lang_flag = 1;
					lang_ch=0;
				}
			}
			if((input == 1)  && (rel==1))
			{
				rel=0;
			}
			state = WAIT_COMMAND;
			break;
		}
		case timecpu1:
		{
			time1[TCNTR++]=(input&0xff);

			if(TCNTR>6)
			{
				TCNTR=0;

				unsigned char video_time1[4] = {0xb1, time1[0], time1[1], time1[2]};
				Write_To_RingBuffer(3, video_time1, 4);

				PTIME.ucHour=time1[0];
				PTIME.ucMin=time1[1];
				PTIME.ucSec=time1[2];
				PTIME.ucMday=time1[4];
				//  PTIME.ucWday=0;
				PTIME.ucMon=time1[3];
				PTIME.usYear=256*time1[6]+time1[5];
				DateNum =umktime(&PTIME);
				ROM_HibernateRTCSet(DateNum);

				filename = 1;

				// These variables are used in the log file:
				curr_year = PTIME.usYear;
				curr_month = PTIME.ucMon;
				curr_day = PTIME.ucMday;
				curr_hour = PTIME.ucHour;
				curr_minute = PTIME.ucMin;
				curr_sec = PTIME.ucSec;

				// in case we changed filename and we want to update the old one.
				if(log_filename[0] == 'i')
				{
					strcpy(log_filename_prev, log_filename);
					usprintf(log_filename,"%02d%02d%02d%02d.txt",(curr_year%100),curr_month,curr_day,curr_hour);

					DebugPrintWithTime("Log file name changed from ");
					DebugPrint(log_filename_prev);
					DebugPrint(" to ");
					DebugPrint(log_filename);
					DebugPrint("\r\n");

					f_rename(log_filename_prev, log_filename);
				}
				state = WAIT_COMMAND;
			}
			break;
		}
		case ACTDEF:
		{
			log_message("Green button pressed.\r\n");

			// If the user presses the green button while not asked for it, ask again.
			if(system_status == SYSTEM_STATUS_DEFIB || defib_activated)
			{
				DebugPrintWithTime("In AED, Ignoring green button.\r\n");
			}
			else if(isStatePressGreen(system_state))
			{
				DebugPrintWithTime("Activate Defibrillator\r\n");
#ifdef NEW_BOARD
				GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0xff);
				SysCtlDelay(10000000);
				GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0x00);
#else
				GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_2 ,0x00);///P10 PIN2-Open the M&b
				GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0xff);
				SysCtlDelay(10000000);
				GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_2 ,0xff);
				GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0xff);
#endif /* NEW_BOARD */

				defib_activated = true;
			}
			else
			{
				usprintf(str,"Not activating Defibrillator system_state = %d prev = %d \0",system_state,prev_system_state);
				DebugPrintWithTime(str);
				DebugPrint("\r\n");
				saved_system_state = system_state;
				//prev_system_state = SYSTEM_STATE_NONE;
				system_state = SYSTEM_STATE_PRESS_GREEN_IF_NO_RESPONSE;
			}
			state = WAIT_COMMAND;
			break;
		}
		case receive_file_name:
		{
			if(input == 0)
			{
				DebugPrintWithTime("Receiving file ");
				DebugPrint(CPU1_transfer_file_name);
				DebugPrint("\r\n");
				name_i = 0;
				state = WAIT_COMMAND;
			}
			else
			{
				CPU1_transfer_file_name[name_i] = input;
				name_i++;
			}
			break;
		}
		case receive_file_size:
			if(input == 0x0C)
			{
				DebugPrintWithTime("File size: ");
				DebugPrintInt(CPU1_transfer_file_size);
				DebugPrint("\r\n");
				transfer_file_digit = 1;
				state = WAIT_COMMAND;
			}
			else
			{
				if(transfer_file_digit == 1)
				{
					CPU1_transfer_file_size = 0;
				}
				CPU1_transfer_file_size += (input - '0') * transfer_file_digit;
				transfer_file_digit = transfer_file_digit * 10;
			}
			break;
		case receive_file_data:
			break;				
		default:
			break;
		}
	}
}
#endif 

//*****************************************************************************
// Routine: VF_algorithm
// Input: none
// Output: none
// Function: This function detects vf/vt using tci algorithm
//*********************************************************************
#ifdef cpu1
void VF_algorithm()
{
	static int T1=25,T2=25,T3=25,T4=25,Bold=0;
	static int Nold=1;
	static int counthigh=0;
	static int countlow=0;
	static char flaglow=0;
	static char flaghigh=0;
	int  N,B100[100];
	int v;
	int NUM1=0;
	int v1;
	char FirstN;
	if(VF100FLAG)
	{ 
		int Thersold=0;
		for(v=VF100Cntr1-100;v<VF100Cntr1;v++)
		{
			if(abs(vf_buffer[v])>abs(Thersold))Thersold=vf_buffer[v];
		}

		Thersold=Thersold*4/10;
		N=0;
		FirstN=true;
		for(v1=0,v=VF100Cntr1-100;v<VF100Cntr1;v++,v1++)
		{   
			number_old=N;
			if(Thersold<0)
			{
				if(vf_buffer[v]<Thersold)
				{   
					B100[v1]=1;
					counthigh++;
					countlow=0;
					if(counthigh>=5)
					{flaghigh=1;
					counthigh=0;
					countlow=0;
					}
					if((flaglow==1) && (flaghigh==1))
					{
						NUM1++;
						flaghigh=0;
						flaglow=0;
					}	
					if(Bold==0) N++;


					if((N==1)&& (FirstN==true))
					{   
						FirstN=false;
						T4=v1;

						computeTci(Nold,T1,T2,T3,T4);
						T2=v1;
						T1=T3;
					}
				}
				else
				{    
					countlow++;
					counthigh=0;
					if(countlow>=10)
					{
						flaghigh=0;
						flaglow=1;
						countlow=0;
						counthigh=0;
					}

					B100[v1]=0;
					if(Bold==1) T3=99-v1;
				}

			}
			else 
			{
				if(vf_buffer[v]>Thersold)
				{   
					B100[v1]=1;
					counthigh++;
					countlow=0;
					if(counthigh>=5)
					{
						flaghigh=1;
						counthigh=0;
						countlow=0;
					}
					if((flaglow==1) && (flaghigh==1))
					{
						NUM1++;
						flaghigh=0;
						flaglow=0;
					}
					if(Bold==0) N++;

					if((N==1)&& (FirstN==true))
					{   
						FirstN=false;
						T4=v1;

						computeTci(Nold,T1,T2,T3,T4);
						T2=v1;
						T1=T3;
					}
				}
				else
				{   
					countlow++;
					counthigh=0;
					if(countlow>=10)
					{ 
						flaghigh=0;
						flaglow=1;
						countlow=0;
						counthigh=0;
					}
					B100[v1]=0;
					if(Bold==1) T3=99-v1;
				}
			}
			Bold= B100[v1];
		}
		VF100FLAG=0;
		Nold=NUM1;
	}
}
#endif

#ifdef cpu1
//*****************************************************************************
// Routine: void MonitoringChecks()
// Input: none
// Output: none
// Function: This function runs every CPU1 timer interrupt, it checks the vital
//			 signes of the patient and changes state by the flow chart.
//*****************************************************************************
void MonitoringChecks()
{
	static int counthr = 0;
	static unsigned int prev_heart_rate = 0;
	isMonitoringChecksDone = true;


	//DebugPrint("MonitoringChecks ");
	//if(!isToolsChecked)
	//return;
	//DebugPrint("isToolsChecked ");

	// We want at least 2 time to get zero to ignore anomalies
	if(heart_rate == 0 && prev_heart_rate != 0)
	{
		prev_heart_rate = 0;
		return;	
	}
	prev_heart_rate = heart_rate;


	counthr++;
	if(counthr == 200)
	{
		counthr = 0;
		if(system_state == SYSTEM_STATE_ADVANCED_SCREEN || system_state == SYSTEM_STATE_MONITORING)
		{	
			static int prev_hr_sources = 0;
			static int prev_hr = 60;
			static int prev_br = 10;
			static int prev_spo2 = 97;
			static int prev_st_elev = 0;
			int play_sound = false;

			//DebugPrint("[Sending HR to screen] ");
			unsigned char video_heart_rate[4] = {0x88, 0, heart_rate / 16, heart_rate % 16};
			Write_To_RingBuffer(3, video_heart_rate, 4);

			hr_sources = ProbeNotConnected + clampNotConnected * 2;

			unsigned char video_heart_sources[2] = {0x84, hr_sources};
			Write_To_RingBuffer(3, video_heart_sources, 2);

			if(system_state == SYSTEM_STATE_ADVANCED_SCREEN)
			{
				// Play sound if hr goes red
				if(prev_hr >=  50 && heart_rate < 50 || prev_hr <=  120 && heart_rate > 120)
				{
					play_sound = true;
				}
				prev_hr = heart_rate;

				// Play sound if br goes red
				if(prev_br >=  6 && average_resprate < 6 || prev_br <=  35 && average_resprate > 35)
				{
					play_sound = true;

					// update screen
					breath_rate_value_send[1]=(char)((average_resprate>>4) & 0x0f);
					breath_rate_value_send[2]=(char)(average_resprate & 0x0f);

					Write_To_RingBuffer(3, breath_rate_value_send, 3);
				}
				prev_br = average_resprate;

				//sending spo2 value to video
				SPO2_rate_value_send[1]=(char)((spo2value>>4) & 0x0f);
				SPO2_rate_value_send[2]=(char)(spo2value & 0x0f);

				unsigned char video_spo2[3] = {0x87, SPO2_rate_value_send[1], SPO2_rate_value_send[2]};

				Write_To_RingBuffer(3, video_spo2, 3);

				// Play sound if spo2 goes red
				if(prev_spo2 >=  90 && spo2value < 90)
				{
					play_sound = true;
				}
				prev_spo2 = spo2value;

				// Play sound if st elevation
				if(events[EVENT_ST_ELEVATION] && prev_st_elev == 0)
				{
					play_sound = true;
					prev_st_elev = 1;
				}

				// Play sound if tool got disconnected
				if((hr_sources % 2) == 1 && (prev_hr_sources % 2) == 0 ||
						(hr_sources / 2) == 1 && (prev_hr_sources / 2) == 0)
				{
					if(system_state == SYSTEM_STATE_ADVANCED_SCREEN)
					{
						play_sound = true;
					}
				}
				prev_hr_sources = hr_sources;

				if(play_sound)
				{
					unsigned char warning_sound[2]={0x82,0x19};
					Write_To_RingBuffer(2, warning_sound, 2);
				}
			}
		}	
	}

	//DebugPrintMonitor();

	if((system_status == SYSTEM_STATUS_DEFIB && !shock_not_advised_flag) || system_status == SYSTEM_STATUS_CPR)
	{
		return;
	}

	if(during_first_10_seconds == 0)
	{
		if(VF_Detected == true && vf_detected_counter == 200 && vf_detected_timer > 0 && system_state != SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN && !defib_activated)
		{
			DebugPrintWithTime("Event: VF suspected.\r\n");
			log_message("Event: VF suspected.");
			system_state = SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN;
			vf_detected_timer = 2000; //restart the ten second counter.
			return;
		}
		else if(vf_detected_timer == 0) //we reached ten seconds whithout reaching 200 vfs detected, so restart the counter and the timer
		{
			vf_detected_counter = 0;
			vf_detected_timer = 2000;
		}
		else
		{
			vf_detected_timer--;
			vf_detected_counter++;
		}

		if(heart_rate > 160 && (!clampNotConnected || !ProbeNotConnected))
		{
			if(high_heart_rate_detected_counter == 3000 && high_heart_rate_timer == 0 && system_state != SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN && !defib_activated)
			{
				DebugPrintWithTime("Event: High heart rate.\r\n");
				log_message("Event: High heart rate");
				system_state = SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN;
				high_heart_rate_timer = 3000; //restart the fifteen second counter.
				return;
			}
			else
			{
				if(high_heart_rate_detected_counter < 3000)
				{
					high_heart_rate_detected_counter ++;
				}

				if(high_heart_rate_timer > 0)
				{
					high_heart_rate_timer --;
				}
			}
		}
		else //heart rate isn't high so restart counter and timer.
		{
			high_heart_rate_detected_counter = 0;
			high_heart_rate_timer = 3000;
		}

		if(heart_rate < 30  && (!clampNotConnected || !ProbeNotConnected))
		{
			if(low_heart_rate_detected_counter == 3000 && low_heart_rate_timer == 0 && system_state != SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN && !defib_activated)
			{
				DebugPrintWithTime("Event: Low heart rate.\r\n");
				log_message("Event: Low heart rate");
				system_state = SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN;
				low_heart_rate_timer = 3000; //restart the fifteen second counter.
				return;
			}
			else
			{
				if(low_heart_rate_detected_counter < 3000)
				{
					low_heart_rate_detected_counter++;
				}

				if(low_heart_rate_timer > 0)
				{
					low_heart_rate_timer--;
				}
			}
		}
		else //heart rate isn't low so restart counter and timer.
		{
			low_heart_rate_detected_counter = 0;
			low_heart_rate_timer = 3000;
		}

		static int count_10lpm = 3000;

		// Set O2 to 10 lpm if: SpO2<94 OR ST elevation OR HR<40 OR HR>120
		if((!ProbeNotConnected && spo2value < 94 && spo2value > 0)     ||
				events[EVENT_ST_ELEVATION]                 ||
				(!ProbeNotConnected && heart_rate < 40)    ||
				(!ProbeNotConnected && heart_rate > 120)   ||
				(VF_Detected))
		{
			if(count_10lpm) count_10lpm --;
			else if(level != 3)
			{
				DebugPrintWithTime("O2 Increased to 10 LPM.\r\n");
				log_message("O2 Increased to 10 LPM.");
				//Increase O2 to 10 LPM
				oxygen_status = OXYGEN_STATUS_10;
				level = 3;
				count_10lpm = 3000;
			}
		}
		else
		{
			count_10lpm = 3000;
		}

		if(system_state != SYSTEM_STATE_MONITORING && system_state != SYSTEM_STATE_ADVANCED_SCREEN)
			return;

		if(system_state == SYSTEM_STATE_ADVANCED_SCREEN && during_first_45_seconds)
			return;
	}

	// check status is not CPR or DEFIB
	/*if(shock_not_advised_flag && (system_status != SYSTEM_STATUS_CPR) && (system_status != SYSTEM_STATUS_DEFIB))
	{
		//if heart rate is too high  or too low and we've already counted 15 seconds of this situation
		if((!ProbeNotConnected || !clampNotConnected) && (heart_rate < 30)  || (heart_rate > 160) || (CprDueToVF == true))
		{
			if(count_hr_cpr <= 0 || CprDueToVF == true)
			{
				if(!MonitorStatusFlag)
				{
					MonitorStatusFlag = 1;
				}

				DebugPrint("Press green is if: HR < 30 OR HR > 160");
				usprintf(str,"Heart rate: %d spo2: %d br = %d ", heart_rate, spo2value, average_resprate);
				DebugPrint(str);

				usprintf(str,"system_status = %d, shock_not_advised_flag = %d \0", system_status, shock_not_advised_flag);
				DebugPrint(str);

				saved_system_state = SYSTEM_STATE_MONITORING;

				system_state = SYSTEM_STATE_START_CPR;
				cpr_from_sali = true;

				if(CprDueToVF == true)
				{
					vf_cpr_counter = 0;
					vf_cpr_timer = 2000;
					CprDueToVF = false;
				}
				else
				{
					count_hr_cpr = 3000;
				}

				return;
			}
		}
	}*/


	if(average_resprate >= 6)
	{
		check_ecg = true;
		silence_mask = 0;
		countmask = 0;
	}

	if((average_resprate < 6) && (system_state != SYSTEM_STATE_ADVANCED_SCREEN) && (!silence_mask) && (passed_first_sensors_slides == true))
	{
		// check status is not CPR or DEFIB
		if(system_status != SYSTEM_STATUS_CPR && (system_status != SYSTEM_STATUS_DEFIB || shock_not_advised_flag) && system_state != SYSTEM_STATE_PRESS_GREEN_IF_NO_RESPONSE)
		{
			check_ecg = false;

			if(countmask < 4)
				countmask++;

			if(countmask == 4)
			{
				if(ProbeNotConnected)
				{
					if(shock_not_advised_flag)
					{
						silence_probe = 0;
						check_tools();
					}
				}
				else
				{
					check_ecg = true;
					check_tools();
				}

				countmask = 0;
				silence_mask = 200 * 60 * 2;
				return;
			}
			else if(countmask == 3)
			{
				system_state = SYSTEM_STATE_REMOVE_SECRETION;
				return;
			}	
			else if(countmask < 3)
			{
				system_state = SYSTEM_STATE_CHECK_MASK;
				return;
			}	
		}
	}
}
#endif

//*****************************************************************************
// Routine: New_event
// Input: none
// Output: none
// Function: This function determines a new postive event
// 
//
//*********************************************************************
void send_update_event(char *upeven)
{ 
	int i;
	for (i=0;i<3;i++)
	{
		if(upeven[i]!=9)
		{	
			s_even[i][1]=upeven[i];

			unsigned char video_update_event[2] = {s_even[i][0], s_even[i][1]};
			Write_To_RingBuffer(3, video_update_event, 2);
		}
	}
}

//*********************************************************************
// Routine: void log_Event(char event_num)
// Input: Event type
// Output: None
// Function: This function logs a message to the log file
//*********************************************************************
void log_Event(char event_type)
{
	char str_event[50];
	int st1 = 0;

	switch(event_type)
	{
	case EVENT_SHOCK:
		DebugPrintWithTime("Event: Shock Delivered Event.\r\n");
		log_message("Event: Shock Delivered Event.");
		break;

	case EVENT_VF:
		DebugPrintWithTime("Event: VF Event.\r\n");
		log_message("Event: VF Event.");
		break;

	case EVENT_CPR:
		DebugPrintWithTime("Event: CPR instructed\r\n");
		log_message("Event: CPR instructed.");
		break;

	case EVENT_LOW_SPO2:
		usprintf(str_event,"Event: Low SpO2 (%d). \0", spo2value);
		log_message(str_event);
		DebugPrintWithTime(str_event);
		DebugPrint("\r\n");
		break;

	case EVENT_ST_ELEVATION:
		if(ST == 10000) st1 = 0;
		else if(is_ST_negative) st1 = (int)ST * -1;
		else st1 = ST;

		usprintf(str_event,"Event: ST elevation (%d.%d mV). \0", st1/100, st1 % 100);
		log_message(str_event);
		DebugPrintWithTime(str_event);
		DebugPrint("\r\n");
		break;

	case EVENT_LOW_HR:
		usprintf(str_event,"Event: Low heart rate (%d). \0", heart_rate);
		log_message(str_event);
		DebugPrintWithTime(str_event);
		DebugPrint("\r\n");
		break;

	case EVENT_HIGH_HR:
		usprintf(str_event,"Event: High heart rate (%d). \0", heart_rate);
		log_message(str_event);
		DebugPrintWithTime(str_event);
		DebugPrint("\r\n");
		break;

	case EVENT_LOW_BR:
		usprintf(str_event,"Event: Low breath rate (%d). \0", average_resprate);
		log_message(str_event);
		DebugPrintWithTime(str_event);
		DebugPrint("\r\n");
		break;

	case EVENT_HIGH_BR:
		usprintf(str_event,"Event: High breath rate (%d). \0", average_resprate);
		log_message(str_event);
		DebugPrintWithTime(str_event);
		DebugPrint("\r\n");
		break;
	}		
}

//*****************************************************************************
// Routine: New_event
// Input: none
// Output: none
// Function: This function determent a new postive event
// 
//
//*********************************************************************
void New_Event()
{ 
	int i,j=0;
	for (i=0;i<9;i++)
	{
		if((events[i]^event_old[i] )& events[i])///postive change in event
		{
			new_event = i;
			if(j<3)
			{
#ifdef cpu2
				WRITEEVENT=true;
#endif			
#ifdef cpu1
				log_Event(i);
#endif			
				priority[j]=i;
				j++;
			}
		}

		event_old[i] = events[i];
		if(i == EVENT_ST_ELEVATION)
		{
			event_old[i] = events[i];
		}	
	}
}

//*****************************************************************************
// Routine: setting_priorty
// Input: none
// Output: none
// Function: This function determent the event to be send according to its priorty
// 
//
//*********************************************************************
void setting_priorty()
{ 
	int i,j=0,k=0,l=0,t=0;
	char upeven[3]={9,9,9};
	for (i=0;i<3;i++)  //old priority contiants the situation on the screen
	{ 
		for(j=k;j<3;j++)
		{
			if(priority[i]<=old_priority[j])
			{

				for(l=2;l>j;l--)
				{
					old_priority[l]=old_priority[l-1];
				}
				old_priority[j]=priority[i];
				upeven[j]=priority[i];//event contains the changes in priority
				priority[i]=9;
				//  ROM_UARTCharPut(UART0_BASE,0x09);
				//ROM_UARTCharPut(UART0_BASE,upeven[j]);
				//ROM_UARTCharPut(UART0_BASE,j);
				//ROM_UARTCharPut(UART0_BASE,0x0a);
			}
		}
		k=j+1;
		//break;
		///k=j+1;

	}
	for(t=0;t<3;t++)
	{
		//ROM_UARTCharPut(UART0_BASE,old_priority[t]);
	}
	//ROM_UARTCharPut(UART0_BASE,0x13);
	//RingBufWrite(&sRingBuf_adv,s_even[0], 2);
	//RingBufWrite(&sRingBuf_adv,s_even[1], 2);
	//RingBufWrite(&sRingBuf_adv,s_even[2], 2);
	//	if(firstti==1)
	//{
	// upeven[0]=1;
	//   upeven[1]=2;
	//   upeven[2]=3;
	//   firstti=false;
	//}
	send_update_event(upeven);
}

//*****************************************************************************
// Routine: EVENT_DETECT_cpu2
// Input: none
// Output: none
// Function: This function calc the remaining of o2 and sending to the screen
//the result 
//
//*********************************************************************
/*EVENT_DETECT_cpu2()
{ 
	return;

	static char countHighrate=0;
	static char countLowrate=0;
	static char  countST=0;
	static char countRESL=0;
	static char  countRESH=0;
	static char  spovalue=0;

	//   Debug(100);
	if (SECFOREVENT2 > 0)SECFOREVENT2--;///every sec checking the event
	if(SECFOREVENT2 == 0)
	{ 
		if (HR_flag_2)
		{
			if(heart_rate > 120)
			{
				countHighrate++;
				countLowrate = 0;
			}
			else if(heart_rate < 50)
			{	
				countHighrate = 0;
				countLowrate++;
			}
			else
			{	
				countHighrate = 0;
				countLowrate = 0;
				events[EVENT_HIGH_HR] = false;
				events[EVENT_LOW_HR] = false;
			} 
			HR_flag_2=0;
		}///HR_LOGIC     
		else if(dspo2rate_flag_2)
		{
			if(spo2rate > 120)
			{
				countHighrate++;
				countLowrate = 0;
			}
			else if(spo2rate < 50)
			{
				countHighrate = 0;
				countLowrate++;
			}
			else
			{	
				countHighrate = 0;
				countLowrate = 0;
				events[EVENT_HIGH_HR] = false;
				events[EVENT_LOW_HR] = false;
			} 
			dspo2rate_flag_2 = 0;
		}
		if(countHighrate >= event_repeat_times)
		{
			events[EVENT_HIGH_HR] = true;
			new_event_value = heart_rate;
			countHighrate = 0;
		}
		if(countLowrate >= event_repeat_times && !during_first_45_seconds)
		{
			events[EVENT_LOW_HR] = true;
			new_event_value = heart_rate;
			countLowrate = 0;
		}
		if(ST_FLAG_2)             //st
		{
			if(ST > 10 && !is_ST_negative)
				countST++;
			else
			{  
				countST = 0;
				events[EVENT_ST_ELEVATION] = false;
			}
			if(countST >= event_repeat_times * 2)
			{
				events[EVENT_ST_ELEVATION] = true;
				new_event_value = ST;
				countST = 0;
			}
			ST_FLAG_2 = 0;
		}
		if(avg_flag_2)
		{
			if(average_resprate > 35)
			{
				countRESH++;
				countRESL = 0;
			}
			else if((average_resprate < 6) && (average_resprate > 0))
			{
				countRESL++;
				countRESH = 0;
			}
			else
			{
				countRESL = 0;
				countRESH = 0;
				events[EVENT_HIGH_BR] = false;
				events[EVENT_LOW_BR] = false;
			}
			if(countRESH >= event_repeat_times)
			{
				events[EVENT_HIGH_BR] = true;
				new_event_value = average_resprate;
				countRESH = 0;
			}
			if(countRESL >= event_repeat_times)
			{
				events[EVENT_LOW_BR] = true;
				new_event_value = average_resprate;
				countRESL = 0;
			}
			avg_flag_2 = 0;
		}
		if(dspo2value_flag_2)
		{
			if(spo2value < 90)
				spovalue++;
			else
			{
				spovalue = 0;
				events[EVENT_LOW_SPO2] = false;
			}
			if(spovalue >= event_repeat_times)
			{
				events[EVENT_LOW_SPO2] = true;
				new_event_value = spo2value;
				spovalue = 0;
			}
			dspo2value_flag_2=0;
		}
		//	if(vf_flag)
		//events[0]=true;

		//	if(cpr_flag)
		//{events[1]=true;}
		New_Event();
		//ROM_UARTCharPut(UART0_BASE,0x20);
		//setting_priorty();

		//M_even[1]=priority[0];
		//RingBufWrite(&sRingBuf_adv,M_even, 2);
		//sec_even[1]=priority[1];
		//RingBufWrite(&sRingBuf_adv,sec_even, 2);
		//third_even[1]=priority[2];
		//RingBufWrite(&sRingBuf_adv,third_even, 2);
		//ROM_UARTCharPut(UART0_BASE,0x02);
		// ROM_UARTCharPut(UART0_BASE,priority[0]);
		//ROM_UARTCharPut(UART0_BASE,priority[1]); 
		//ROM_UARTCharPut(UART0_BASE,priority[2]);

		SECFOREVENT2=500;
	}
}*/

//******************************************************************************
// Routine: EVENT_DETECT
// Input: none
// Output: none
// Function: This function detects events and sends the events to cpu2 and cpu3
//the result 
//
//******************************************************************************
#ifdef cpu1
void EVENT_DETECT()
{ 
	static int countHighrate=0;
	static int countLowrate=0;
	static int countST=0;
	static int countRESL=0;
	static int countRESH=0;
	static int spovalue=0;

	static int last_second = 0;

	if(last_second == 0)
	{ 
		last_second = 200;
		if (HR_flag_1 && !clampNotConnected)
		{
			if(heart_rate == 0 && first_5_seconds)
			{
				countLowrate = 0;
			}
			else if(heart_rate > 120)
			{
				if(countHighrate != -1)	countHighrate++;
				countLowrate = 0;
			}
			else if(heart_rate < 50)
			{
				countHighrate = 0;
				if(countLowrate != -1) countLowrate++;
			}
			else
			{	
				countHighrate = 0;
				countLowrate = 0;
				events[EVENT_HIGH_HR] = false;
				events[EVENT_LOW_HR] = false;
			} 
			HR_flag_1 = 0;
		}///HR_LOGIC     
		else if(dspo2rate_flag && !ProbeNotConnected)
		{
			if(spo2rate > 120)
			{
				if(countHighrate != -1)	countHighrate++;
				countLowrate = 0;
			}
			else if(spo2rate < 50)
			{
				countHighrate = 0;
				if(countLowrate != -1) countLowrate++;
			}
			else
			{	
				countHighrate = 0;
				countLowrate = 0;
				events[EVENT_HIGH_HR] = false;
				events[EVENT_LOW_HR] = false;
			} 
			dspo2rate_flag = 0;
		}
		if(countHighrate >= event_repeat_times)
		{
			//Sending HR to screen		

			unsigned char video_high_hr[4] = {0x88, 0, heart_rate / 16, heart_rate % 16};
			Write_To_RingBuffer(3, video_high_hr, 4);

			unsigned char hr_event[3]={0x97, heart_rate / 16, heart_rate % 16};
			Write_To_RingBuffer(2, hr_event, 3);

			events[EVENT_HIGH_HR] = true;
			countHighrate = -1;
		}
		if(countLowrate >= event_repeat_times  && !during_first_45_seconds)
		{
			//Sending HR to screen

			unsigned char video_low_hr[4] = {0x88, 0, heart_rate / 16, heart_rate % 16};
			Write_To_RingBuffer(3, video_low_hr, 4);

			unsigned char hr_event[3]={0x98, heart_rate / 16, heart_rate % 16};
			Write_To_RingBuffer(2, hr_event, 3);

			events[EVENT_LOW_HR] = true;
			countLowrate = -1;
		}

		if(ST_flag && !clampNotConnected)             //st
		{
			if(ST > 10 && !is_ST_negative)
			{
				if(countST < event_repeat_times * 2)
				{
					if(countST != -1) countST++;
				}
			}
			else
			{  
				countST = 0;
				events[EVENT_ST_ELEVATION] = false;
			}
			if(countST >= event_repeat_times * 2)
			{
				countST = -1;

				//Sending ST elevation event to cpu2
				unsigned char st_event[1]={0x9c};
				Write_To_RingBuffer(2, st_event, 1);

				events[EVENT_ST_ELEVATION] = true;
			}
			ST_flag = 0;
		}
		if(resp_ready && !first_20_seconds)
		{
			if(average_resprate > 35)
			{
				if(countRESH != -1) countRESH++;
				countRESL = 0;
			}
			else if(average_resprate < 6 && MaskAttachedSituation>=1000)
			{
				if(countRESL != -1) countRESL++;
				countRESH = 0;
			}
			else
			{
				countRESL = 0;
				countRESH = 0;
				events[EVENT_HIGH_BR] = false;
				events[EVENT_LOW_BR] = false;
			}
			if(countRESH >= event_repeat_times)
			{
				// update screen
				breath_rate_value_send[1]=(char)((average_resprate>>4) & 0x0f);
				breath_rate_value_send[2]=(char)(average_resprate & 0x0f);

				Write_To_RingBuffer(3, breath_rate_value_send, 3);

				unsigned char br_event[3]={0x99, average_resprate / 16, average_resprate % 16};
				Write_To_RingBuffer(2, br_event, 3);

				events[EVENT_HIGH_BR] = true;
				new_event_value = average_resprate;
				usprintf(str,"EVENT_HIGH_BR new_event_value = %d \0", new_event_value);
				DebugPrintWithTime(str);
				DebugPrint("\r\n");
				countRESH = -1;
			}
			if(countRESL >= event_repeat_times)
			{
				// update screen
				breath_rate_value_send[1]=(char)((average_resprate>>4) & 0x0f);
				breath_rate_value_send[2]=(char)(average_resprate & 0x0f);

				Write_To_RingBuffer(3, breath_rate_value_send, 3);

				unsigned char br_event[3]={0x9a, average_resprate / 16, average_resprate % 16};
				Write_To_RingBuffer(2, br_event, 3);

				events[EVENT_LOW_BR] = true;
				new_event_value = average_resprate;
				usprintf(str,"EVENT_LOW_BR new_event_value = %d \0", new_event_value);
				DebugPrintWithTime(str);
				DebugPrint("\r\n");
				countRESL = -1;	
			}
			resp_ready = 0;
		}
		if(dspo2value_flag && !ProbeNotConnected)
		{
			//sending spo2 value to video
			SPO2_rate_value_send[1]=(char)((spo2value>>4) & 0x0f);
			SPO2_rate_value_send[2]=(char)(spo2value & 0x0f);

			unsigned char video_spo2[3] = {0x87, SPO2_rate_value_send[1], SPO2_rate_value_send[2]};

			Write_To_RingBuffer(3, video_spo2, 3);

			if(spo2value < 90)
			{
				if(spovalue != -1)	spovalue++;
			}
			else
			{
				spovalue = 0;
				events[EVENT_LOW_SPO2]=false;
			}

			if(spovalue >= event_repeat_times)
			{
				usprintf(str,"EVENT_LOW_SPO2 spo2_event_value = %d \0", spo2value);
				DebugPrintWithTime(str);
				DebugPrint("\r\n");

				unsigned char spo2_event[3]={0x9b, spo2value / 16, spo2value % 16};
				Write_To_RingBuffer(2, spo2_event, 3);

				events[EVENT_LOW_SPO2] = true;
				spovalue = -1;
			}
			dspo2value_flag = 0;
		}			

		New_Event();
		setting_priorty();
	}
	else
	{
		last_second--;
	}
}
#endif

//*****************************************************************************
// Routine: O_remain
// Input: none
// Output: none
// Function: This function calc the remaining of o2 and sending to the screen
//the result 
//
//*********************************************************************
#ifdef cpu1
void O_remain()
{
	static int O2_minutes_remaining = 30;
	static int went_to_10_lpm = false;

	//if 15 minutes have passed with the door closed.
	if(O2_reset)
	{
		O2_minutes_remaining = 30;
		O2_reset = 0;
		went_to_10_lpm = false;

		// Send to screen (advanced screen)
		unsigned char video_o2_count[4] = {0x86, 0, O2_minutes_remaining, 0};
		Write_To_RingBuffer(3, video_o2_count, 4);

		// Send to emergency center
		unsigned char o2_minutes[2]={0x84, O2_minutes_remaining};
		Write_To_RingBuffer(2, o2_minutes, 2);

		O2_counter = 200 * 60; // 1 minute for 5 LPM 30 seconds for 10 LPM

		level = 1;
	}

	// we want to stop the count if the door is closed.
	if(door_state == CLOSE)
	{
		return;
	}

	// count one minute.
	if(O2_counter > 0)
	{
		O2_counter = O2_counter - 1;
	}

	// if went up to 10 lpm, cut in half the remaining time
	if(level == 3 && !went_to_10_lpm)
	{
		went_to_10_lpm = true;
		O2_minutes_remaining = O2_minutes_remaining / 2;
	}

	if(O2_counter == 0)
	{
		// counted 1 minute less.
		if(O2_minutes_remaining > 0)
			O2_minutes_remaining = O2_minutes_remaining - 1;

		// Send to screen (advanced screen)
		unsigned char video_o2_count[4] = {0x86, 0, O2_minutes_remaining, 0};
		Write_To_RingBuffer(3, video_o2_count, 4);

		// Send to emergency center
		unsigned char o2_minutes[2]={0x84, O2_minutes_remaining};
		Write_To_RingBuffer(2, o2_minutes, 2);

		O2_counter = 200 * 60; // 1 minute for 5 LPM 30 seconds for 10 LPM
	}

	if(!O2_minutes_remaining && !O2_alert_timer && cylinderMessageTimes < 3)
	{
		if(system_state == SYSTEM_STATE_MONITORING && prev_system_state == SYSTEM_STATE_MONITORING)
		{
			saved_system_state = SYSTEM_STATE_MONITORING;
			system_state = SYSTEM_STATE_EMPTY_CYLINDER;
		}
		else if(system_state == SYSTEM_STATE_ADVANCED_SCREEN && prev_system_state == SYSTEM_STATE_ADVANCED_SCREEN)
		{
			saved_system_state = SYSTEM_STATE_ADVANCED_SCREEN;
			system_state = SYSTEM_STATE_EMPTY_CYLINDER;
		}
	}
}

//*****************************************************************************
// Routine: Respiration_Rate
// Input: none
// Output: none
// Function: This function calc the RR and sending to the screen the result
//
//*****************************************************************************
void Respiration_Rate()
{
	int sum = 0;
	int index = 1;
	int num_of_samples = 0;
	static int counter = 0;

	// if last breath is more than 20 seconds then its an apnea
	if(br_buffer[0] >= 1000)
	{
		average_resprate = 0;
	}
	else if(br_buffer[0] >= 500)
	{
		average_resprate = (int)(3000.0f / (float)br_buffer[0]);	
	}
	else
	{
		while(sum < 3000 && index < 6)
		{
			sum += br_buffer[index];
			if(br_buffer[index] > 0) num_of_samples++;
			index++;
		}
		if(sum  == 0)
			average_resprate = 0;
		else if(sum >= 3000)
			average_resprate = num_of_samples;
		else if (index == 6)
		{
			average_resprate = (int)((3000.0f / (float)sum) * (float)num_of_samples);
		}
	}

	//don't want to calculate the breath rate if we still don't have at least 5 breaths
	if(br_buffer[4] == 0)
	{
		average_resprate = 0;
	}

	resp_ready=1;

	// Send the resp rate to the screen once every 1 second
	counter++;
	if(counter == 200)
	{
		//DebugPrint("Sending Breath Rate ");
		breath_rate_value_send[1]=(char)((average_resprate>>4) & 0x0f);
		breath_rate_value_send[2]=(char)(average_resprate & 0x0f);

		Write_To_RingBuffer(3, breath_rate_value_send, 3);

		unsigned char average_resp[2]={0x83, average_resprate};
		Write_To_RingBuffer(2, average_resp, 2);

		counter = 0;
	}

	if(average_resprate>0 && MaskAttachedSituation<1000)
	{
		MaskAttachedSituation++;
	}

	if((average_resprate==0) && (spo2value>95)&& spomsg[1]!=15)
	{   
		maskNotConnected=1;
	}
	else 
	{
		maskNotConnected=0;
	}
}

//*****************************************************************************
// Routine: Handle_Oxygen
// Input: none
// Output: none
// Function: This function opens the oxygen cylinder and closes it
//
//*****************************************************************************
void Handle_Oxygen() 
{    
	static int openingCylinder = false;  

	// Opening one or two Oxygen Solenoids
	GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_1 ,oxygen_level[level][0]);
	GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_2 ,oxygen_level[level][1]);

	if(ox_flag==1)
	{
		// opening Oxygen cylinder
		DebugPrintWithTime("opening Oxygen cylinder \r\n");
#ifdef NEW_BOARD
		GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_0 ,0xff);
		GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_0 ,0xff);
#else
		GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_0 ,0xff);
		GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_0 ,0x00);
#endif /* NEW_BOARD */
		openingCylinder = true;		
	}
	else if (ox_flag==2)
	{
		// closing Oxygen cylinder
		DebugPrintWithTime("closing Oxygen cylinder \r\n");
#ifdef NEW_BOARD
		GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_0 ,0x00);
		GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_0 ,0x00);
#else
		GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_0 ,0x00);
		GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_0 ,0xff);
#endif /* NEW_BOARD */
	}
	if(ox_flag==1)
	{
#ifdef RUN_PARTIAL_MOTOR
		oxygen=60;
#else
		oxygen=2400;
#endif
		ox_flag=3;
	}
	if(ox_flag==2)
	{
		oxygen=700;
		ox_flag=3;
	}

	if(oxygen>0)
	{
		oxygen--;
	}
	else if(ox_flag==4) ox_flag = 1;
	else if(ox_flag==3)
	{
		// Stop opening/closing the cylinder
		GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_0 ,0x00);
		GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_0 ,0x00);

		if(openingCylinder)
		{
			openingCylinder = false;
			//After finished opening the cylinder, aquire the baseline pressure 	
			br_state = 1;		
		}
	}
}
#endif

//*****************************************************************************
// Routine: ReadUART2_anddecode
// Input: none
// Output: none
// Function: This function gets the information from uart2 and decodes it
//
//
//*****************************************************************************
#ifdef cpu1
void ReadUART2_anddecode()
{
	char  InputChar;
	while(ROM_UARTCharsAvail(UART2_BASE))
	{
		//
		// Read the next character from the UART and write it back to the UART(for cpu2) and also decode him.
		//
		InputChar=(0xff&ROM_UARTCharGetNonBlocking(UART2_BASE));
		//ROM_UARTCharPut(UART0_BASE,InputChar);
		usprintf(str,"InputChar = %d",InputChar);
		//DebugPrint(str);

		button_decode_cpu1(InputChar);
	}
}

//*****************************************************************************
// Routine: void Update_tools_CPU2()
// Input: none
// Output: none
// Function: This function updates cpu2 with the state of the tools
//*****************************************************************************
void Update_tools_CPU2()
{
	unsigned char tools_state[1];

	if(ProbeNotConnected == 1)
	{
		tools_state[0] = 0x94;
		Write_To_RingBuffer(2, tools_state, 1);

		ProbeWasNotConnected = true;
	}

	if(clampNotConnected == 1)
	{
		tools_state[0] = 0x93;
		Write_To_RingBuffer(2, tools_state, 1);

		clampWasNotConnected = true;
	}

	if(ProbeWasNotConnected && ProbeNotConnected == 0)
	{
		tools_state[0] = 0x96;
		Write_To_RingBuffer(2, tools_state, 1);

		ProbeWasNotConnected = false;
	}

	if(clampWasNotConnected && clampNotConnected == 0)
	{
		tools_state[0] = 0x95;
		Write_To_RingBuffer(2, tools_state, 1);

		clampWasNotConnected = false;
	}
}

//*****************************************************************************
// Routine: check_tools()
// Input: none
// Output: none
// Function: This function Check if the probe the mask and clamps are connected or not 
//
//
//*****************************************************************************
void check_tools()
{	
	static char countprobe = 0;
	static char countecg = 0;
	static int  counter = 200;

	if(counter == 0)
	{
		Update_tools_CPU2();
		counter = 200;
	}
	else
	{
		counter--;
	}

	if(system_state != SYSTEM_STATE_MONITORING && system_state != SYSTEM_STATE_ALL_SENSORS_IN_PLACE)
		return;

	if(system_state == SYSTEM_STATE_ALL_SENSORS_IN_PLACE)
	{
		passed_first_sensors_slides = true;
	}

#ifdef NO_TOOL_CHECK
	system_state = SYSTEM_STATE_MONITORING;
	isToolsChecked = true;	
	return;
#endif	

	if(!clampNotConnected)
	{
		silence_ecg = 0;
		countecg = 0;
	}

	if(!ProbeNotConnected)
	{
		silence_probe = 0;
		countprobe = 0;
	}

	if(ProbeNotConnected && !silence_probe && !MonitorStatusFlag)
	{
		if(countprobe == 2)
		{
			silence_probe = 200 * 60;
			countprobe = 0;
			silence_mask = 0;
		}
		else
		{
			system_state = SYSTEM_STATE_CHECK_PROBE;
			countprobe++;
		}
		check_ecg = false;
	}
	else if(clampNotConnected && !silence_ecg && check_ecg && !MonitorStatusFlag)
	{
		if(countecg == 2)
		{
			silence_ecg = 200 * 60 * 2;
			countecg = 0;
		}
		else
		{
			system_state = SYSTEM_STATE_CHECK_ECG_STICKERS;
			countecg++;
		}
	}
	else if(!MonitorStatusFlag)
	{
		if(saved_system_state != SYSTEM_STATE_ADVANCED_SCREEN)
		{
			system_state = SYSTEM_STATE_MONITORING;
		}
		else
		{
			system_state = saved_system_state;
		}
	}
	else // we shouldn't be here but if we reached this somehow, we don't want to get stuck
	{
		if(system_status == SYSTEM_STATUS_CPR && system_state != SYSTEM_STATE_START_CPR && system_state != SYSTEM_STATE_CPR_HAND_LOCATION &&
		   system_state != SYSTEM_STATE_CPR_PUSH && system_state != SYSTEM_STATE_CPR_START_PUSH && system_state != SYSTEM_STATE_PAY_ATTENTION_CPR)
		{
			system_state = SYSTEM_STATE_START_CPR;
		}
	}

	isToolsChecked = true;
}

//*****************************************************************************
// Routine: void update_batt_icon()
// Input: none
// Output: none
// Function: This function Updates battery icon on the screen
//***************************************************************************** 
void update_batt_icon()
{
	static int batt_counter = 0;
	static int status = BATT_STATE_LOW;
	static int prev_bat = 0;
	static int low_bat_counter = 0;

	if(!isLoadingDone) return;

	if(batt_counter == 0)
	{
		//if there is a physical problem with the sali.
		if(atp_results_cpu1)
		{
			if(isBattCharging)
			{
				atp_results_cpu1 = atp_results_cpu1 & CHARGING;
				status = ERROR_WHILE_CHARGING;
			}
			else
			{
				status = ERROR;
			}
		}
		else //no physical problem known.
		{
			if(isBattCharging)
			{
				if(batt > 2800) //charging while full
				{
					status = BATT_STATE_CHARGE_FULL;
				}
				else if((batt > 2600) && (status != BATT_STATE_CHARGE_FULL)) //charging_while medium or high
				{
					if(((status != BATT_STATE_LOW) && (status != BATT_STATE_CHARGE_LOW)) || (batt > 2630))
					{
						status = BATT_STATE_CHARGE;
					}
					else
					{
						status = BATT_STATE_CHARGE_LOW;
					}
				}
				else if(status != BATT_STATE_CHARGE) //charging while low
				{
					status = BATT_STATE_CHARGE_LOW;
				}
			}
			else
			{
				if((batt > 2650)) //battery high
				{
					if((status != BATT_STATE_MEDIUM) || ((batt - prev_bat) > 30) || ((prev_bat - batt) > 30)) // if we haven't yet reached the medium battery status and the jump wasn't very big from last time
					{
						status = BATT_STATE_HIGH;
					}
				}
				else if((batt > 2600)) //battery medium
				{
					if((status != BATT_STATE_LOW) || ((batt - prev_bat) > 30) || ((prev_bat - batt) > 30)) // if we haven't yet reached the low battery status and the jump wasn't very big from last time
					{
						status = BATT_STATE_MEDIUM;
					}
				}
				else //battery low
				{
					status = BATT_STATE_LOW;
				}
			}

			if(batt < 2400 && !isBattCharging)
			{
				low_bat_counter++;
			}
			else
			{
				low_bat_counter = 0;
			}

			// Show low bat warning and go to sleep.
			if(low_bat_counter >= 10 &&
			   system_state != SYSTEM_STATE_LOW_BATT &&
			   system_state != SYSTEM_STATE_SLEEP &&
			   system_state != SYSTEM_STATE_SELF_TEST &&
			   system_status != SYSTEM_STATUS_DEFIB &&
			   system_state != SYSTEM_STATE_BACKDOOR1 &&
			   system_state != SYSTEM_STATE_BACKDOOR2)
			{
				system_state = SYSTEM_STATE_LOW_BATT;
				low_bat_counter = 0;
			}

			prev_bat = batt;
		}

		batt_counter = 200;

		//send the battery/error status to cpu3.
		unsigned char video_batt_stat[2] = {0x90, status};
		Write_To_RingBuffer(3, video_batt_stat, 2);
	}

	if(batt_counter > 0)
	{
		batt_counter--;
	}
}

//*****************************************************************************
// Routine: void update_comm_icon()
// Input: none
// Output: none
// Function: This function Updates communication icon on the screen
//***************************************************************************** 
void update_comm_icon()
{
	unsigned char video_update_comm_icon[2] = {0x95, comm_status_cpu1};
	Write_To_RingBuffer(3, video_update_comm_icon, 2);
}

//**********************************************************************************************
// Routine: void hr_cpr_check_counter()
// Input: none
// Output: none
// Function: This function checks the heart rate status and updates the count_hr_cpr accordingly
//***********************************************************************************************
void hr_cpr_check_counter()
{
	// If: HR < 30 OR HR > 160 for 15 seconds.
	if((!ProbeNotConnected || !clampNotConnected) && (heart_rate < 30)  || (heart_rate > 160))
	{
		if(count_hr_cpr > 0)
		{
			count_hr_cpr--;
		}
	}
	else
	{
		MonitorStatusFlag = 0; //the situation is ok...
		count_hr_cpr = 3000;
	}
}

//**********************************************************************************************
// Routine: void vf_check_cpr_counter()
// Input: none
// Output: none
// Function: This function checks the vf status and updates the vf_cpr_counter accordingly
//***********************************************************************************************
void vf_check_cpr_counter()
{
	if(VF_Detected == true && vf_cpr_counter < 200) //if the vf algorithm has detected a vf situation and we still haven't reached 200 such detections.
	{
		vf_cpr_counter++;
	}

	if(vf_cpr_timer > 0) //if we still haven't passed ten seconds.
	{
		vf_cpr_timer--;
	}
	else if(vf_cpr_counter == 200) //ten seconds have passed, and we've counted 200 times of detection in those ten seconds.
	{
		CprDueToVF = true;
	}
	else //if ten seconds have passed and we haven't reached 200 detections, we want to restart timer and counter and change indication of CPR need to false.
	{
		vf_cpr_counter = 0;
		vf_cpr_timer = 2000;
		CprDueToVF = false;
		MonitorStatusFlag = 0; //the situation is ok...
	}
}
#endif

//*****************************************************************************
//CPU1
// The interrupt handler for the second timer interrupt.
// This interrupt will run once per 5 mS 
//  This interrupt will:
//  1.  Call respiration algorithm to obtain respiration rate.2
//  2.  Call switch decoder to see if new switch values are set
//  3.  Open the oxygen clyinder
//  4.  Detcet  vf/vt
//  5.  Change machine state
//  6.  Calc the o2 remaining
//*****************************************************************************
#ifdef cpu1
void Timer1IntHandler_cpu1(void)
{ 
	ROM_TimerIntClear(TIMER1_BASE, TIMER_TIMA_TIMEOUT);

	if(reEnterT1 > 0)
	{
		return;
	}
	reEnterT1=1;

	ReadUART2_anddecode();
	update_batt_icon();
	O_remain();

	if(during_first_45_seconds > 0) during_first_45_seconds--;

	if(during_first_10_seconds > 0) during_first_10_seconds--;

#ifdef DEBUG_CPU2_PRINT
	unsigned long pulData;
	static char cpu_comm_msg[30];
	static int cpu_comm_state = 0;
	static int cpu_comm_index = 0;
	if(isLoadingDone)
	{
		if((SSIDataGetNonBlocking(SSI3_BASE, &pulData))>0)
		{
			if(cpu_comm_state == 0 && pulData == 0xFB)
			{
				//DebugPrint(" cpu2 print: ");
				cpu_comm_state = 1;
				cpu_comm_index = 0;
			}
			else if(cpu_comm_state == 1 && pulData == 0xFC)
			{
				cpu_comm_state = 0;	
				//DebugPrint(cpu_comm_msg);
			}
			else if(cpu_comm_state == 1)
			{
				cpu_comm_msg[cpu_comm_index++] = pulData&0xff;
				//DebugPrint(cpu_comm_msg);	
			}			
		}
	}
#endif
	// count first 5 seconds for heart rate event
	if(first_5_seconds > 0) first_5_seconds--;
	// count first 20 seconds for breath rate event
	if(first_20_seconds > 0) first_20_seconds--;

	// a timer for the advanced screen press time
	if(timer_adv_press > 0) timer_adv_press--;
	if(silence_ecg > 0) silence_ecg--;
	if(silence_probe > 0) silence_probe--;
	if(silence_mask > 0) silence_mask--;

	// Once reconnected, remove silencing 
	if(!clampNotConnected) silence_ecg = 0;
	if(!ProbeNotConnected) silence_probe = 0;

	if(system_state == SYSTEM_STATE_SLEEP)
	{
		if(sleep_ATP_timer > 0)
		{
			sleep_ATP_timer--;
		}
		reEnterT1=0;
		return;
	}
	if(system_state == SYSTEM_STATE_WAKE || 
			system_state == SYSTEM_STATE_STANDBY ||
			system_state == SYSTEM_STATE_SELF_TEST)
	{
		reEnterT1=0;
		return;
	}

	static int inFirstMinute = 60;
	static int count_sec = 0;
	if(count_sec == 200)
	{
		if(inFirstMinute) inFirstMinute--;
		else event_repeat_times = 8;

		PTIME.ucSec++;
		if(PTIME.ucSec == 60)
		{
			PTIME.ucSec = 0;
			PTIME.ucMin++;
			if(PTIME.ucMin == 60)
			{
				PTIME.ucMin = 0;
				PTIME.ucHour++;	
				if(PTIME.ucHour == 24)
				{
					PTIME.ucHour = 0;
					PTIME.ucMday++;

					if(PTIME.ucMday > 31
							|| (PTIME.ucMday > 30 && (PTIME.ucMon == 4 || PTIME.ucMon == 6 || PTIME.ucMon == 9 || PTIME.ucMon == 11))
							|| (PTIME.ucMday > 28 && PTIME.ucMon == 2))
					{
						PTIME.ucMday = 1;
						PTIME.ucMon++;
						if(PTIME.ucMon > 12)
						{
							PTIME.ucMon = 1;
							PTIME.usYear++;
						}
					}					
				}
			}		
		}
		curr_sec = PTIME.ucSec;
		curr_minute = PTIME.ucMin;
		curr_hour = PTIME.ucHour;
		curr_day = PTIME.ucMday;
		curr_month = PTIME.ucMon;
		curr_year = PTIME.usYear;
		count_sec = 0;
	}
	count_sec++;

	if(wait2 > 0) wait2--;
	if(O2_alert_timer > 0) O2_alert_timer--;

	// Dont allow incoming calls during AED sequence.
	if(allow_incoming_calls_CPU1 != allow_incoming_calls_CPU1_cur_state)
	{
		allow_incoming_calls_CPU1_cur_state = allow_incoming_calls_CPU1;

		if(allow_incoming_calls_CPU1)
			h[0] = 0x46;
		else
			h[0] = 0x47;

		unsigned char incoming_calls_status[1] ={h[0]};
		Write_To_RingBuffer(2, incoming_calls_status, 1);
	}

	if(reset1 == wake)///wake
	{
		if(Standby15Minutes)//wake but in standby
		{
			if(system_state == SYSTEM_STATE_COUNT_15_MINUTES)
			{
				if(WaitInStandby == 0)
				{   
					DebugPrintWithTime("15 minutes passed\r\n");
					WaitInStandby=-1;

					unsigned char video_real_sleep[1] = {0xf6};
					Write_To_RingBuffer(3, video_real_sleep, 1);

					system_state = SYSTEM_STATE_SLEEP;
					Standby15Minutes = false;

					//need to reset O2 counter.
					O2_reset = 1;

					//reset1 = sleep;
					//sleep_ATP_timer = -1;
				}
				else if (WaitInStandby>0)
					WaitInStandby--;
			}
			else   
				system_state = SYSTEM_STATE_STANDBY;
		}
		else
		{
			if( WaitInStandby > 0)///waking during wait in standby
			{
				WaitInStandby = -1;

				//waking up the screen
				unsigned char video_wakeup[1] = {0xf1};
				Write_To_RingBuffer(3, video_wakeup, 1);

				system_state = prev_system_state;
				prev_system_state = SYSTEM_STATE_NONE;

				// Un-mute the volume
				unsigned char unmute_vol[2] = {0x82, 101};
				Write_To_RingBuffer(2, unmute_vol, 2);

				// if wake up in advaced,redraw now
				if(system_state == SYSTEM_STATE_ADVANCED_SCREEN)
				{
					//unsigned char adv_background[2] = {0x81, 0x11};
					//Write_To_RingBuffer(3, adv_background, 2);

					hr_sources = 0;
				}
			}
			if(waken_from_sleep)
			{
				waken_from_sleep = 0;

				//waking up the screen
				unsigned char video_wakeup[1] = {0xf1};
				Write_To_RingBuffer(3, video_wakeup, 1);

				system_state = SYSTEM_STATE_PLACE_HEAD_ON_HEADREST;
				prev_system_state = SYSTEM_STATE_NONE;	
				sleep_ATP_timer = -1;
			}
			if (ValidCheckSumFromAED == true) //checksum of aed protocol is okay we have to change statr
			{
				ValidCheckSumFromAED = false;

				switch(state1)///state1 is the state that we get from the AED
				{
				case AED_STATE_CHECK_PADS:
					DebugPrintWithTime("AED_STATE_CHECK_PADS\r\n");
					//allow_incoming_calls_CPU1 = false;
					system_state = SYSTEM_STATE_CHECK_PADS;
					system_status = SYSTEM_STATUS_DEFIB;
					break;

				case AED_STATE_ANALYZING_DONT_TOUCH:
					DebugPrintWithTime("AED_STATE_ANALYZING_DONT_TOUCH\r\n");
					//allow_incoming_calls_CPU1 = false;

					system_state = SYSTEM_STATE_ANALYSIS;
					system_status = SYSTEM_STATUS_DEFIB;
					events[EVENT_SHOCK] = false;
					events[EVENT_VF] = false;
					break;

				case AED_STATE_CHARGING_DONT_TOUCH:
					DebugPrintWithTime("AED_STATE_CHARGING_DONT_TOUCH\r\n");
					system_state = SYSTEM_STATE_CHARGING_DONT_TOUCH;
					break;

				case AED_STATE_SHOCK_ADVISED:
					DebugPrintWithTime("AED_STATE_SHOCK_ADVISED\r\n");
					//allow_incoming_calls_CPU1 = false;
					events[EVENT_VF] = true;

					unsigned char charging_status[1] ={0x91};
					Write_To_RingBuffer(2, charging_status, 1);

					system_state = SYSTEM_STATE_PRESS_RED;
					shock_not_advised_flag = false;
					shock = 1;
					break;

				case AED_STATE_SHOCK_DELIVERED:
					DebugPrintWithTime("AED_STATE_SHOCK_DELIVERED \r\n");
					//allow_incoming_calls_CPU1 = true;
					system_state = SYSTEM_STATE_SHOCK_DELIVERED;
					log_message("Event: Shock delivered.");

					shock_amount ++;

					unsigned char shock_delivered_value_video[2]={0xf4, shock_amount};

					Write_To_RingBuffer(3, shock_delivered_value_video, 2);

					events[EVENT_SHOCK] = true;

					unsigned char shock_given[1] ={0x9d};
					Write_To_RingBuffer(2, shock_given, 1);
					break;

					// No shock advised
				case AED_STATE_NO_SHOCK_ADVISED:
					DebugPrintWithTime("AED_STATE_NO_SHOCK_ADVISED \r\n");

					//allow_incoming_calls_CPU1 = false;

					shock = 0;
					//DebugPrint("AED done so changing state \0");
					//system_state = saved_system_state;
					if(saved_system_state == SYSTEM_STATE_ADVANCED_SCREEN)
					{
						//unsigned char adv_background[2] = {0x81, 0x11};
						//Write_To_RingBuffer(3, adv_background, 2);

						system_state = saved_system_state;
						prev_system_state = SYSTEM_STATE_NONE;
						hr_sources = 0;
					}
					else
					{
						system_state =  SYSTEM_STATE_ALL_SENSORS_IN_PLACE;
					}
					//system_state = SYSTEM_STATE_NO_SHOCK;
					system_status = SYSTEM_STATUS_NONE;
					shock_not_advised_flag = true;
					silence_probe = 0;
					silence_ecg = 0;
					MonitorStatusFlag = 0;
					break;

				case AED_STATE_BEGIN_CPR:
					/*if(!shock_not_advised_flag)
					{
						DebugPrint("AED_STATE_BEGIN_CPR \0");
						//allow_incoming_calls_CPU1 = true;

						if(shock)
						{
							system_state = SYSTEM_STATE_START_CPR;
							cpr_from_sali = false;
						}
					}
					else
					{
						system_state =  SYSTEM_STATE_ALL_SENSORS_IN_PLACE;
						DebugPrint("WAS ABOUT TO START CPR THROUGH AED \0");
					}*/

					DebugPrintWithTime("AED_STATE_BEGIN_CPR\r\n");
					system_state = SYSTEM_STATE_START_CPR;
					cpr_from_sali = false;
					break;

				case AED_STATE_PRESS_GREEN:
					//allow_incoming_calls_CPU1 = false;
					DebugPrintWithTime("AED_STATE_PRESS_GREEN\r\n");
					system_state = SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN;
					break;

				case AED_STATE_STOP_CPR:
					if(!shock_not_advised_flag)
					{
						//allow_incoming_calls_CPU1 = false;
						DebugPrintWithTime("AED_STATE_STOP_CPR\r\n");
						system_state = SYSTEM_STATE_STOP_CPR;
					}
					else
					{
						DebugPrintWithTime("WAS ABOUT TO STOP CPR THROUGH AED\r\n");
					}
					break;

				default:
					break;
				}
			}
		}

#ifdef NO_MGW830		
		clampNotConnected = 0;
		ProbeNotConnected = 0;
		maskNotConnected = 0;
		heart_rate = 60;
		average_resprate = 15;
		spo2value = 98;
#endif	

		// Give priority to the probe
		if(ProbeNotConnected == 0 && spo2rate != 0)
		{
			heart_rate = spo2rate;
		}

		//ReadUART2_anddecode ();
		Handle_Oxygen();
		Respiration_Rate();		
		EVENT_DETECT();
		//update_batt_icon();
		VF_algorithm();

		if(door_state)
		{
			check_tools();//checking if the tools are on the person
			hr_cpr_check_counter(); //checking and updating count_hr_cpr.
			vf_check_cpr_counter(); //checking and updating vf_cpr_counter.
			MonitoringChecks();
		}
	}
	reEnterT1=0;
}
#endif

//*****************************************************************************
// Routine: int is_False_Breath(int press1)
// Input: int press1
// Output: none
// Function: This function receives the current air pressure from the mask,
// 			It operates as a low-pass filter, if it sees a spike in the last 10 
//			samples it marks it as a false breath.
//*****************************************************************************
int is_False_Breath(int press1)
{
#define PRESSURE_SAMPLE_COUNT 10
	static int last_pressure_samples[10] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
	int max_value = -1;
	int min_value = 2147483647;
	int i;
	int ignore_breath = false;

	// Slide window left and take a new sample
	for(i = 0; i < PRESSURE_SAMPLE_COUNT - 1; i++)
	{
		last_pressure_samples[i] = last_pressure_samples[i + 1];
	}
	last_pressure_samples[PRESSURE_SAMPLE_COUNT - 1] = press1;


	// get max and min values
	for(i = 1; i < PRESSURE_SAMPLE_COUNT; i++)
	{
		if(last_pressure_samples[i] != -1 && last_pressure_samples[i - 1] != -1)
		{
			max_value = MAX(max_value, last_pressure_samples[i]);
			min_value = MIN(min_value, last_pressure_samples[i]);
		}
	}

	// check for a state for a spike up or down from the th area
	if((last_pressure_samples[0] > (base_line - th) &&
			last_pressure_samples[PRESSURE_SAMPLE_COUNT - 1] > (base_line - th) &&
			min_value < base_line - 3 *  th) ||

			(last_pressure_samples[0] < (base_line + th) &&
					last_pressure_samples[PRESSURE_SAMPLE_COUNT - 1] < (base_line + th) &&
					max_value > base_line + 3 *  th))
	{
		DebugPrintWithTime("Ignoring breath!!!\r\n");
		ignore_breath = true;
	}
	return ignore_breath;
}

//*****************************************************************************
// Routine: Mask_ADC_IntHandler_cpu1
// Input: none
// Output: none
// Function: This function get A/D value from pressure sensor and battery and calculate them
//
//
//*****************************************************************************
#ifdef cpu1
void Mask_ADC_IntHandler_cpu1(void)
{
	ADCIntClear(ADC0_BASE, 2);
#define MIN_EXHALE_LENGTH 10 // 200 miliseconds
#define MIN_BREATH_LENGTH 20 // 400 miliseconds

#define MIN_EXHALE_LENGTH_LOW  8
#define MIN_BREATH_LENGTH_LOW  16

	static char h1 = 0;
	//static int countbat = 0;

	unsigned long  adc_data[4];
	static signed int sum = 0;
	//static signed int sumbatt = 0;
	signed int press1;
	signed int BAT = 0;
	//static int prev_BAT = 0;

	static int peak_length = 0;
	{
		ADCSequenceDataGet(ADC0_BASE, 2, adc_data);
		{
			static char first_run = 1;
			BAT = (int)adc_data[2];   ////get A/D value of battery
			batt = BAT;

			if(system_state == SYSTEM_STATE_SELF_TEST || system_state == SYSTEM_STATE_SLEEP)
				return;

			press1 = (int)adc_data[1];//get A/D value of mask

			//New breath algorithm
			// get dynamic baseline
			/////////////////////////////
			if(h1 < 100)
			{
				sum = sum + press1;
				h1++;
				return;
			}
			else if(base_line == -1)
			{
				base_line = sum / 100;	
				DebugPrintWithTime("Got base line for mask pressure\r\n");

				char str_mask_base_line[50];

				usprintf(str_mask_base_line,"the mask base line is: (%d). \0", base_line);
				log_message(str_mask_base_line);
				DebugPrintWithTime(str_mask_base_line);
				DebugPrint("\r\n");
			}
			//////////////////////////////

			int i;
			br_buffer[0]++;

			int min_exhale_length = MIN_EXHALE_LENGTH;
			int min_breath_length = MIN_BREATH_LENGTH;
			th = 30;

			// On low breath rate, turn more sensitive
			// and use addaptive baseline
			if(average_resprate < 10)
			{
				min_exhale_length = MIN_EXHALE_LENGTH_LOW;
				//base_line = (base_line * 98 + press1 * 2) / 100;
				//th = 15;
			}
			// On hight breath rate, turn less sensitive.
			else if(average_resprate > 30)
			{
				min_exhale_length = MIN_EXHALE_LENGTH + 1;
				min_breath_length = MIN_BREATH_LENGTH + 1;
				//th = 25;
			}
			/*else
			{
				th = 20;
			}*/

			if(press1 < base_line)
			{
				if(peak_length > min_exhale_length && br_buffer[0] > min_breath_length)
				{
					if(is_first_breath)
					{
						br_buffer[0] = 0;
						is_first_breath = false;
					}

					usprintf(str,"[[[Breath detected peak_length=%d total length=%d", peak_length,br_buffer[0]);
					DebugPrintWithTime(str);
					DebugPrint("]]]\r\n");

					for(i = 9;i > 0;i--)
					{
						br_buffer[i] = br_buffer[i-1];
					}
					br_buffer[0] = 0;
				}
				peak_length = 0;
			}

			if(press1 > (base_line + th))
			{
				peak_length++;
			}
		}
	}
}
#endif

#ifdef cpu2
//*****************************************************************************
// Routine: Audio_decode_cpu2(unsigned long pullData)
// Input: pullData
// Output: none
// Function: Decoding Audio cpu1 to cpu2 communication
//*****************************************************************************		
void Audio_decode_cpu2(unsigned long pullData)
{
	long input;
	static int index_lang = 0;

	input=(long)(pullData & 0xff);

	if(input == -1)return;		//error no character was available

	if(input > 0x80)
	{
		switch( input)
		{
		case 0x82:
			state = NEW_AUDIO;
			break;
		case 0xA0:
			state = NEW_APN;
			break;	
		case 0xA1:
			state = NEW_ATP_RESULTS;
			break;
		case 0xA2:
			comm_activated = true;
			break;
		case 0xBB:
			state = NEW_LANGUAGE;
			break;		
		case 0xBC:
			send_cpu1_id = true;
			//play_audio_cpu2 = 22;
			break;
		case 0xBD: //change to backup language
			lang = 0;
		default:
			break;
		}
	}
	else 
	{
		static int index_apn = 0;
		switch (state) 
		{
		case NEW_AUDIO:
			//toggle_led_2();
			if(input == 0x03 || input == 0x08 || input == 0x15 || input == 0x1B || input == 0x1C)
			{
				if(shouldHearCaller)
				{
					shouldHearCaller = false;
					AudioI2C_Send_cpu2(0,0x01); //move to page 1
					AudioI2C_Send_cpu2(35,0x40); //Disconnect modem from speaker.
					AudioI2C_Send_cpu2(0,0x00); //return to page 0
				}
			}
			else if(!shouldHearCaller)
			{
				shouldHearCaller = true;
				checkCallStatus();
			}

			if(input <= MAX_AUDIO) 
			{
				// Unmute DAC
				if(isSaliSoundMuted)
				{
					AudioI2C_Send_cpu2(64,0x04);
					isSaliSoundMuted = 0;
				}

				char input1=(char)input;
				unsigned char  cmd[2]={input1,0x1};

				unsigned long buffer_used_len = RingBufUsed(&sRingBuf);

				if((buffer_used_len%2))
				{
					RingBufFlush(&sRingBuf);
					f_close(&g_sAudioFileObject);
					currentSoundFile = NULL;
					file_close=2;
					IntDisable(INT_SSI2);
				}

				RingBufWrite(&sRingBuf, cmd, 2);

				buffer_used_len = RingBufUsed(&sRingBuf);

				if(!(buffer_used_len%2))
				{
					loudspeaker_cpu2();
				}

				if(!isGreenButtonLEDOn)
				{
					if(input == 0x10 || input == 0x01) blink_led = true;
					else
					{
						blink_led = false;
						led_off();
					}
				}

				//if we've started a new patient session we want to restart the vf_detection flag.
				if(input == 0x00)
				{
					VF_Detected_cpu2 = false;
				}
			}

			// Mute 
			else if(input == 100)		
			{
				// Mute DAC
				AudioI2C_Send_cpu2(64,0x0C);
				isSaliSoundMuted = 1;

				if(currentSoundFile != NULL) // if a sound file is open, close it first.
				{
					f_close(&g_sAudioFileObject);
					currentSoundFile = NULL;
				}

				door_status = 0;

				if(call_activated)
				{
					disconnectCall();
				}
			}

			// Unmute
			else if(input == 101)
			{
				// Unmute DAC
				AudioI2C_Send_cpu2(64,0x04);
				isSaliSoundMuted = 0;

				unsigned long buffer_used_len = RingBufUsed(&sRingBuf);

				if((buffer_used_len%2))
				{
					RingBufFlush(&sRingBuf);
					f_close(&g_sAudioFileObject);
					currentSoundFile = NULL;
					file_close=2;
					IntDisable(INT_SSI2);
				}

				door_status = 1;

				call_activated = 0;
			} 

			state = WAIT_COMMAND;
			break;
		case NEW_APN:
			APN_cpu2[index_apn++] = (char)input;
			if(input == '\0')
			{
				state = WAIT_COMMAND;
				apn_received_cpu2 = true;
			}
			break;
		case NEW_ATP_RESULTS:
			atp_result_cpu2 = (char)input;
			cpu2_new_atp = true;
			//play_audio_cpu2 = 22;
			state = WAIT_COMMAND;
			break;
		case NEW_LANGUAGE:
			if(index_lang == 0) lang_a[0] = (char)input;
			else if(index_lang == 1) lang_a[1] = (char)input;		
			else if(index_lang == 2) lang_b[0] = (char)input;
			else if(index_lang == 3)
			{
				lang_b[1] = (char)input;
				state = WAIT_COMMAND;	
				index_lang = -1;
			}		
			index_lang++;

			//if we're done reading the langauges input, we want to save the data onto sd card 2, so that we'll be covered if cpu2 restarts.
			if(index_lang == 0)
			{
				char lang_string[6];

				lang_string[0] = lang_a[0];
				lang_string[1] = lang_a[1];
				lang_string[2] = ' ';
				lang_string[3] = lang_b[0];
				lang_string[4] = lang_b[1];
				lang_string[5] = '\n';

				write_to_file(lang_string, "lang.txt", FA_WRITE | FA_CREATE_ALWAYS);
			}
			break;
		default:
			break;
		}
	}
}

//*****************************************************************************
// Routine:  decode_resp_rate_cpu2(unsigned long pullData)
// Input: pullData
// Output: none
// Function: Decoding resp rate and o_remain
//*****************************************************************************	
void decode_resp_rate_cpu2(unsigned long pullData)
{
	char input;
	//static int i=0;
	input=(long)(pullData & 0xff);

	if(input == 0xff)return;		//error no character was available

	if(input > 0x80)
	{
		switch( input)
		{
		case 0x83:
			SSIDataGet(SSI3_BASE, &pullData);
			average_resprate = (char)(pullData & 0xff);
			avg_flag_2 = true;		
			//state = NEW_RASP_RATE;
			break;
		case 0x84:	
			state = NEW_O_REMAIN;
			break;
		case 0x87:	
			state = WAIT_COMMAND;
			break;
		case 0xD7:
			// sleep mode	
			comm_state = 3;
			isSleeping_CPU2 = true;
			// Get back to default language
			lang=1;// change default lang
			break;
		case 0xD8:
			isSleeping_CPU2 = false;
			// wakeup mode	
			comm_state = 4;

			eventId[0] = '0';
			eventId[1] = '0';
			eventId[2] = '0';
			eventId[3] = '0';	

			startTime[0] = '0';
			startTime[1] = '0';
			startTime[3] = '0';
			startTime[4] = '0'; 
			startTime[6] = '0';
			startTime[7] = '0';    

			break;
		case 0x91:
			if(VF_Detected_cpu2 == false)
			{
				VF_Detected_cpu2 = true;
				events[EVENT_VF] = true;
				New_Event();
			}
			break;	
		case 0x92:	
			CPR_Detected_cpu2 = true;
			events[EVENT_CPR] = true;
			New_Event();
			break;	
		case 0x93:
			clampNotConnected_cpu2 = true;
			break;
		case 0x94:
			ProbeNotConnected_cpu2 = true;
			break;
		case 0x95:
			clampNotConnected_cpu2 = false;
			break;
		case 0x96:
			ProbeNotConnected_cpu2 = false;
			break;
		case 0x97:	
			events[EVENT_HIGH_HR] = true;
			SSIDataGet(SSI3_BASE, &pullData);
			new_event_value = pullData * 16;
			SSIDataGet(SSI3_BASE, &pullData);
			new_event_value += pullData;
			New_Event();
			break;
		case 0x98:
			events[EVENT_LOW_HR] = true;
			SSIDataGet(SSI3_BASE, &pullData);
			new_event_value = pullData * 16;
			SSIDataGet(SSI3_BASE, &pullData);
			new_event_value += pullData;
			New_Event();	
			break;		
		case 0x99:
			events[EVENT_HIGH_BR] = true;
			SSIDataGet(SSI3_BASE, &pullData);
			new_event_value = pullData * 16;
			SSIDataGet(SSI3_BASE, &pullData);
			new_event_value += pullData;
			New_Event();	
			break;
		case 0x9a:
			events[EVENT_LOW_BR] = true;
			SSIDataGet(SSI3_BASE, &pullData);
			new_event_value = pullData * 16;
			SSIDataGet(SSI3_BASE, &pullData);
			new_event_value += pullData;
			New_Event();
			break;	
		case 0x9b:
			events[EVENT_LOW_SPO2] = true;
			SSIDataGet(SSI3_BASE, &pullData);
			new_event_value = pullData * 16;
			SSIDataGet(SSI3_BASE, &pullData);
			new_event_value += pullData;
			New_Event();
			break;			
		case 0x9c:
			events[EVENT_ST_ELEVATION] = true;
			New_Event();
			break;
		case 0x9d:
			events[EVENT_SHOCK] = true;
			New_Event();
			break;
		default:
			break;
		}
	}
	else 
	{
		switch (state) 
		{
		case NEW_RASP_RATE:
		{
			average_resprate=(input&0xff);
			//average_resprate = 78;
			avg_flag=1;
			avg_flag_1=1;
			state = WAIT_COMMAND;
			break;
		}
		case NEW_O_REMAIN:
		{
			o2_remain = (input&0xff);
			O_flag_1=1;
			O_flag=1;
			state = WAIT_COMMAND;
			break;
		}
		default:
			break;
		}
	}
}

//*****************************************************************************
// Routine:  GetRtc(unsigned long pullData)
// Input: pullData
// Output: none
// Function: GetRtc-sending start working of cpu1
//*****************************************************************************	
void GetRtc(unsigned long pullData)
{	 
	long input;

	input=(long)(pullData & 0xff);

	if(input == -1)return;		//error no character was available

	if(input== 0x86)
	{
		clock=1;
		state = Time;
		stage=First;				
	}
	else if(state == Time)
	{
		switch (stage) {
		case First:
			RTtime=input;

			stage = Second;

			break;
		case Second:
			RTtime=(input<<8)+RTtime;

			stage = Third;
			break;
		case Third:
			RTtime=(input<<16)+RTtime;

			stage = Four;
			break;
		case Four:
			RTtime=(input<<24)+RTtime;
			// clock=1;
			state = WAIT_COMMAND;
			break;
		default:
			break;
		}
	}
}

//extern void send_mount_state(int state);

//*****************************************************************************
// Routine:  void GetCodeFromCPU1(unsigned long pullData)
// Input: pullData
// Output: none
// Function: gets a code from CPU1 and activates the appropriate flag on CPU2.
//*****************************************************************************	
void GetCodeFromCPU1(unsigned long pullData)
{
	long input;
	static int last_mount_state = -1;

	input=(long)(pullData & 0xff);
	if(input == -1)return;		//error no character was available

	if(input== 0x46) // Turn on phone calls
	{
		allow_incoming_calls_CPU2 = true;	
	}
	else if(input== 0x47) // Turn off phone calls
	{
		allow_incoming_calls_CPU2 = false;	
	}		
	else if(input== 0x48) // SALI off wall
	{
		if(last_mount_state != 0 && comm_status_cpu2)// send_mount_state(0);
		{
			last_mount_state = 0;
			sali_on_wall_cpu2 = false;
		}
	}
	else if(input== 0x49) // SALI on wall
	{
		if(last_mount_state != 1)
		{
			// Play charge sound
			play_audio_cpu2 = 0x18;
		}

		if(last_mount_state != 1 && comm_status_cpu2)// send_mount_state(1);
		{
			last_mount_state = 1;
			sali_on_wall_cpu2 = true;
		}
	}	
}
#endif


//*****************************************************************************
//CPU2
// The interrupt handler for the second timer interrupt.
// This interrupt will run once per 2 mS 
//  This interrupt will:
//	1.  Decode audio
//  2.  Get the resp rate
//  3.  Get the openning of the door
//  4.  Decode buttons
//  5.  Save information on the SDcard
//  6.  Increase the clock  
//
//*****************************************************************************
#ifdef cpu2
void Timer0IntHandler_cpu2(void)
{ 
	int i;	
	static int inFirstMinute = 60;

	//check modem call status
	if(comm_status_cpu2 == true && modem_call_status_timer == 0)
	{
		modem_call_status_check = true;
		modem_call_status_timer = 200;
	}
	/*else
	{
		modem_call_status_check = false;
	}*/

	if(modem_call_status_timer > 0)
	{
		modem_call_status_timer--;
	}

	if(reEnterT0 > 0)
	{
		return;
	}

	reEnterT0 = 1;

	if(cpu2_wait_for_answer > 0) cpu2_wait_for_answer--;

	if(during_first_45_seconds > 0) during_first_45_seconds--;
	if(count_5_secs > 0) count_5_secs--;

	if(count_one_second_cpu2 >= 500)
	{ 	
		count_one_second_cpu2 = 0;
		curr_sec++;

		if(modem_tmo > 0)
		{
			modem_tmo--;
		}

		if(inFirstMinute)
		{
			inFirstMinute--;
		}
		else
		{
			event_repeat_times = 8;
		}

		if(blink_led)
		{
			toggle_led();
		}

		if(curr_sec == 60)
		{
			curr_sec = 0;
			curr_minute++;

			if(curr_minute == 60)
			{
				curr_minute = 0;
				curr_hour++;

				if(curr_hour == 24)
				{
					curr_hour = 0;
					curr_day++;
				}
			}
		}
	}
	count_one_second_cpu2++;

	ROM_TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

	unsigned long pulData;

	if((SSIDataGetNonBlocking(SSI3_BASE, &pulData))>0)
	{
		Audio_decode_cpu2(pulData);
		decode_resp_rate_cpu2(pulData);
		GetRtc(pulData);
		GetCodeFromCPU1(pulData);
	}
	else if(play_audio_cpu2)
	{
		state = NEW_AUDIO;
		Audio_decode_cpu2(play_audio_cpu2);
		play_audio_cpu2 = 0;
		state = WAIT_COMMAND;
	}

	//This section for the audio 	
	if(buffer_1_empty) 
	{
		buffer_1_empty=0;
		fresult = f_read(&g_sAudioFileObject, audio,512,&usBytesRead);
		if (usBytesRead<512)
		{
			EOF_buffer1=1;	
			for(i=0;i<(512-usBytesRead);i++)
				audio[usBytesRead+i]=0;	
		}	

	}
	else if(buffer_2_empty)
	{
		buffer_2_empty=0;			
		fresult = f_read(&g_sAudioFileObject, audio+512,512,&usBytesRead);
		if (usBytesRead<512)
		{
			EOF_buffer2=1;
			for(i=0;i<(512-usBytesRead);i++)audio[usBytesRead+i+512]=0;
		}
	}

	if(run_advanced_timer)
	{
		advanced_press_timer++;
	}

	switch_decoder_adv_cpu2();
	switch_decoder_adv_cpu21();
	switch_decoder_adv_cpu22();

	//EVENT_DETECT_cpu2();

	if(u15_clock)
	{
		curr_year = year;
		curr_month = month;
		curr_day = day;
		curr_hour = hour;
		curr_minute = minute;
		curr_sec = sec;

		ROM_UARTCharPut(UART2_BASE,0xE6);
		ROM_UARTCharPut(UART2_BASE,hour);
		ROM_UARTCharPut(UART2_BASE,minute);
		ROM_UARTCharPut(UART2_BASE,sec);
		ROM_UARTCharPut(UART2_BASE,month);
		ROM_UARTCharPut(UART2_BASE,day);
		ROM_UARTCharPut(UART2_BASE,(year&0xff));
		ROM_UARTCharPut(UART2_BASE,((year>>8)&0xff));

		usprintf(log_filename,"%02d%02d%02d%02d.txt",(year%100),month,day,hour);

		u15_clock=0;
	}

	//End of audio section
	if(clock==1)
	{   
		comm_state = 1;
		timeslice1=0;
		timechan=0;
		clock=2;

	}
	else if(clock==2)
	{
		if(timeslice1==420)
		{///ROM_UARTCharPut(UART7_BASE,'t');
			timeslice1=0;
			RTtime++;
			timechan++;
		}
		else
		{
			timeslice1++;

		}
	}

	reEnterT0 = 0;
}

void Timer1IntHandler_cpu2(void)
{
	ROM_TimerIntClear(TIMER1_BASE, TIMER_TIMA_TIMEOUT);

	if(reEnterT1 > 0)
	{
		return;
	}
	reEnterT1=1;

#ifdef ENABLE_WATCHDOG
	if(watch_dog_counter > 0)
	{
		watch_dog_counter--;

		if(watch_dog_counter == 0)
		{
			g_bFeedWatchdog = false;
		}
	}
#endif // ENABLE_WATCHDOG

	reEnterT1 = 0;
}

#endif

#ifdef cpu1
//*****************************************************************************
// Routine:  GPIOB1IntHandler
// Input: none
// Output: none
// Function:GPIOB1 handler -FOR THE CHARGING CONNECTOR
//
//*****************************************************************************
void GPIOB1IntHandler(void)
{
	int status;
	status = GPIOPinIntStatus(GPIO_PORTB_BASE, GPIO_PIN_4);
	if(status == GPIO_PIN_4)
	{
		//DebugPrint("!!!!!!!!!!!!!!!!!!!!!!PortB pin 4!!!!!!!!!!!!!");
		GPIOPinIntClear(GPIO_PORTB_BASE, GPIO_PIN_4); // Clear the GPIO interrupt.
	}
	status = GPIOPinIntStatus(GPIO_PORTB_BASE, GPIO_PIN_5);
	if(status == GPIO_PIN_5)
	{
		//DebugPrint("!!!!!!!!!!!!!!!!!!!!!!PortB pin 5!!!!!!!!!!!!!");
		GPIOPinIntClear(GPIO_PORTB_BASE, GPIO_PIN_5); // Clear the GPIO interrupt.
		input = (GPIOPinRead(GPIO_PORTB_BASE, GPIO_PIN_5) & GPIO_PIN_5);		 //get value
		usprintf(str,"[input = %d] \0", input);
		//DebugPrint(str);

		if(input == 0)
		{
			DebugPrintWithTime("Charger Conneced.\r\n");
			isBattCharging = true;
			GPIOIntTypeSet(GPIO_PORTB_BASE, GPIO_PIN_5, GPIO_HIGH_LEVEL);
		}
		else
		{
			DebugPrintWithTime("Charger Disconneced.\r\n");
			isBattCharging = false;
			GPIOIntTypeSet(GPIO_PORTB_BASE, GPIO_PIN_5, GPIO_LOW_LEVEL);
		}
	}		
}

//*****************************************************************************
// Routine:  GPIOE1IntHandler
// Input: none
// Output: none
// Function:GPIOE handler -FOR OPENNING THE DOOR
//
//*****************************************************************************
void GPIOE1IntHandler(void)
{   
	int status = GPIOPinIntStatus(GPIO_PORTE_BASE, GPIO_PIN_7);
	if(status == GPIO_PIN_7)
	{
		GPIOPinIntClear(GPIO_PORTE_BASE, GPIO_PIN_7); // Clear the GPIO interrupt.
		switch_decoder_cpu1();

		// if the door is opened
		// Then start the Sali.
		if(door_state == OPEN)
		{
			if(system_state == SYSTEM_STATE_SLEEP)
			{

				//system_status = SYSTEM_STATUS_NONE;
				DebugPrintWithTime("Door opened while sleeping, waking up\r\n");
				wake_from_sleep = true;
			}
			else if(system_state == SYSTEM_STATE_SELF_TEST)
			{
				system_status = SYSTEM_STATUS_NONE;
				DebugPrintWithTime("Door opened during self test, will wakeup after it finishes.\r\n");
				wake_after_self_test = true;
			}
			else
			{
				wake_from_sleep = true;
			}
		}
		else //door closed
		{
			wake_from_sleep = false;
		}
	}
	status = GPIOPinIntStatus(GPIO_PORTE_BASE, GPIO_PIN_6);
	if(status == GPIO_PIN_6)
	{
		GPIOPinIntClear(GPIO_PORTE_BASE, GPIO_PIN_6); // Clear the GPIO interrupt.
		switch_decoder2_cpu1();
	}
}
#endif

#ifdef cpu2
//*****************************************************************************
//
// Background Routine
//
//*****************************************************************************
unsigned int GetTimeslice(void)
{

	return timeslice;
}
#endif

//*****************************************************************************
// Routine:  Debug(int freq)
// Input: freq-number of flashing led
// Output: none
// Function:In order to Debug function
//*****************************************************************************
void Debug(int freq)
{
	int i;
	for(i = 0;i < freq * 2; i++)
	{
		GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_7 ,0x00);
		GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_1 ,0x00);
		SysCtlDelay(ROM_SysCtlClockGet()/freq);
		// ROM_UARTCharPut(UART7_BASE,'r');
		GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_1 ,0xff);
		GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_7 ,0xff);
		SysCtlDelay(ROM_SysCtlClockGet()/freq);
		//ROM_UARTCharPut(UART7_BASE,'U');
	}
}

//*****************************************************************************
// Routine:  DebugPrintWithTime(char* str)
// Input:    A string to output to the computer via UART0. (use Serial Watcher to receive)
// Output:   none
// Function: In order to Debug function
//*****************************************************************************
void DebugPrintWithTime(char* str)
{
#ifdef DEBUG
	int index = 0;
	char time_stamp[20];

	//print time
	usprintf(time_stamp,"[%02d:%02d:%02d]: ",curr_hour,curr_minute,curr_sec);

	while(time_stamp[index] != '\0')
	{
		ROM_UARTCharPut(UART0_BASE,time_stamp[index]);
		index++;
	}

	DebugPrint(str);
#endif
}

//*****************************************************************************
// Routine:  DebugPrint(char* str)
// Input:    A string to output to the computer via UART0. (use Serial Watcher to receive)
// Output:   none
// Function: In order to Debug function
//*****************************************************************************
void DebugPrint(char* str)
{
#ifdef DEBUG
	int index = 0;

	while(str[index] != '\0')
	{
		ROM_UARTCharPut(UART0_BASE,str[index]);
		index++;
	}
#endif // DEBUG
}

//*****************************************************************************	
// Routine: void DebugPrintInt(int num)
// Input: num
// Output: none
// Function: Prints a number to the computer.
//*****************************************************************************	
void DebugPrintInt(int num)
{
	//#ifdef DEBUG
	int digit;
	int digits = 0;
	char str[20];
	while(num > 0)
	{
		digit = num % 10; 
		num = num / 10;
		str[digits] = digit + '0';
		digits++;
	}

	int i;
	for(i = digits - 1; i >= 0; i--)
	{
		ROM_UARTCharPut(UART0_BASE, str[i]);	
	}
	ROM_UARTCharPut(UART0_BASE, ' ');
	//#endif
}

#ifdef cpu1
//*****************************************************************************
// Routine:  void DebugPrintMonitor(char* str)
// Input: str
// Output: none
// Function: Prints a string to the computer, prits once every 500 times called,
//           used for putting in the timer interrupt.
//*****************************************************************************	
void DebugPrintMonitor()
{
	char monitor_str[200];
	static int counter = 0;

	if(system_state == SYSTEM_STATE_COUNT_15_MINUTES || !isLoadingDone)
		return;

	counter = (counter + 1) % 500;
	if(counter != 0)
		return;

	int st1 = 0;

	if(ST == 10000) st1 = 0;
	else if(is_ST_negative) st1 = (int)ST * -1;
	else st1 = ST;


	usprintf(monitor_str," << MONITOR [HR=%d] [ST=%d] [RESP=%d] [SPO2=%d] [BAT = %d] [state = %d] [status = %d] >> \0", heart_rate, st1, average_resprate , spo2value, batt, system_state, system_status);	
	int index = 0;
	while(monitor_str[index] != '\0')
	{
		ROM_UARTCharPut(UART0_BASE, monitor_str[index]);
		index++;
	}

	//char batt_str[20];
	//usprintf(batt_str,"Battery: %d \0", batt);
	//log_message(batt_str);
}
#endif

//*****************************************************************************
// Routine:  Audio_init_cpu2(void)
// Input: none
// Output: none
// Function:Initialzition of Audio by I2C
//*****************************************************************************
#ifdef cpu2
void Audio_init_cpu2(void)
{
	int i;

	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
	GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_7);
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
	GPIOPinTypeGPIOOutput(GPIO_PORTD_BASE, GPIO_PIN_1);

	//
	// Initialize the i2c.
	//
	SysCtlPeripheralEnable(SYSCTL_PERIPH_I2C1);
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
	ROM_GPIOPinConfigure(GPIO_PA6_I2C1SCL);			
	ROM_GPIOPinConfigure(GPIO_PA7_I2C1SDA);
	I2CMasterEnable(I2C1_MASTER_BASE);
	GPIOPinTypeI2C(GPIO_PORTA_BASE, GPIO_PIN_6| GPIO_PIN_7);
	GPIOPadConfigSet(GPIO_PORTA_BASE, GPIO_PIN_6, GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD_WPU);
	GPIOPadConfigSet(GPIO_PORTA_BASE, GPIO_PIN_7, GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_OD_WPU);
	I2CMasterInitExpClk(I2C1_MASTER_BASE, SysCtlClockGet(), false);
	//I2CMasterIntEnable(I2C1_MASTER_BASE);

	//
	// Initialize the ssi2 used for sound s.
	//

	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOH);
	GPIOPinTypeGPIOOutput(GPIO_PORTH_BASE, GPIO_PIN_5);
	GPIOPinTypeGPIOOutput(GPIO_PORTH_BASE, GPIO_PIN_4);
	GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_5 ,0xff);

	GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_5 ,0x00);
	for(i=0;i<14;i++){//14
		GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_4 ,0xff);
		GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_4 ,0x00);
		GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_4 ,0xff);
	}

	SysCtlPeripheralEnable(SYSCTL_PERIPH_SSI2);


	GPIOPinTypeSSI(GPIO_PORTH_BASE, SSI2_CLK | SSI2_RX |SSI2_TX );	
	GPIOPinConfigure(GPIO_PH4_SSI2CLK);

	GPIOPinConfigure(GPIO_PH6_SSI2RX);
	GPIOPinConfigure(GPIO_PH7_SSI2TX);

	SSIDisable(SSI2_BASE);
	SSIConfigSetExpClk(SSI2_BASE, SysCtlClockGet(), SSI_FRF_MOTO_MODE_0,SSI_MODE_MASTER, 1500000, 16);
	HWREG(SSI2_BASE + SSI_O_CR1) |= SSI_CR1_EOT;
	SSIEnable(SSI2_BASE);

	//
	//  Initialize Audio
	//

	SysCtlDelay(ROM_SysCtlClockGet()/20);

	AudioI2C_Send_cpu2(0,0);
	AudioI2C_Send_cpu2(1,1);

	SysCtlDelay(ROM_SysCtlClockGet()/20);

	// Clock and Interface Settings
	// ---------------------------------------------
	// The codec receives: MCLK = 16.00 MHz,
	// BLCK = 2.8224 MHz, WCLK = 44.1 kHz
	//	
	AudioI2C_Send_cpu2(4,3);			//mclk is input to pll
	AudioI2C_Send_cpu2(5,0x91);
	AudioI2C_Send_cpu2(6,0x05);
	AudioI2C_Send_cpu2(7,0x0b);
	AudioI2C_Send_cpu2(8,0x68);
	SysCtlDelay(ROM_SysCtlClockGet()/2000);
	AudioI2C_Send_cpu2(11,0x85);		//NDAC = 4, MDAC = 4, dividers powered on
	AudioI2C_Send_cpu2(12,0x83);
	SysCtlDelay(ROM_SysCtlClockGet()/2000);
	AudioI2C_Send_cpu2(13,0x00);		//DOSR = 128
	AudioI2C_Send_cpu2(14,0x80);
	SysCtlDelay(ROM_SysCtlClockGet()/2000);
	AudioI2C_Send_cpu2(27,0xc0);
	AudioI2C_Send_cpu2(29,0x00);
	// 
	//   Signal Processing Settings
	//		PRB_P25

	AudioI2C_Send_cpu2(60,0x04);	//16//04xxx	//19 for beep
	//AudioI2C_Send_cpu2(61,0x05);			//DATA sheet says this should be 8 not 5
	AudioI2C_Send_cpu2(0,0x09);
	AudioI2C_Send_cpu2(2,0xef);		
	AudioI2C_Send_cpu2(3,0xff);			//DATA sheet says this should be 8 not 5
	AudioI2C_Send_cpu2(4,0x0);			//DATA sheet says this should be 8 not 5
	AudioI2C_Send_cpu2(5,0x0);			//DATA sheet says this should be 8 not 5
	AudioI2C_Send_cpu2(6,0x0);
	AudioI2C_Send_cpu2(7,0x0);			//DATA sheet says this should be 8 not 5


	AudioI2C_Send_cpu2(0,0x00);


	AudioI2C_Send_cpu2(0,3);
	AudioI2C_Send_cpu2(16,90);				//sets internal clock not shown
	AudioI2C_Send_cpu2(0,0);
	//Enable processing
	AudioI2C_Send_cpu2(63,0x95);//95
	AudioI2C_Send_cpu2(64,0x04);

	AudioI2C_Send_cpu2(65,VOLUME);

	AudioI2C_Send_cpu2(117,0);
	// 
	//   Configure Class D output
	//		
	AudioI2C_Send_cpu2(0,0x01);

	//AudioI2C_Send_cpu2(33,0x38); //Driver ramp-up step time	
	//AudioI2C_Send_cpu2(34,0x70); //Driver ramp-up step time	
	AudioI2C_Send_cpu2(30,0x03);		
	AudioI2C_Send_cpu2(31,0x84);			//DAT
	AudioI2C_Send_cpu2(32,0x86);			//DAT
	AudioI2C_Send_cpu2(35,0x40);			//DATA change to 60 for adding voice or 40 to disconnect modem
	AudioI2C_Send_cpu2(50,0x80);			//DATA 
	//AudioI2C_Send_cpu2(50,0x80);			//DATA 
	AudioI2C_Send_cpu2(38,0x80);//90micxxx
	AudioI2C_Send_cpu2(40,0x06);			//DATA

	AudioI2C_Send_cpu2(42,0x1d);		//15xxx

	// 
	//   Configure Class D output
	//		

	AudioI2C_Send_cpu2(0x00,0x00);		
	AudioI2C_Send_cpu2(0x63,0xb6);//b5xxx

	//
	//	Enable all Outputs		
	//

	// 
	//   Configure Class D output
	//		
	AudioI2C_Send_cpu2(0x73,0xff);	
	AudioI2C_Send_cpu2(0x74,0x00);//problem&&&&&&&&&&&&&&&&	
	AudioI2C_Send_cpu2(0x75,0xff);		
	AudioI2C_Send_cpu2(0x76,0x00);		
	AudioI2C_Send_cpu2(0x77,0x51);		
	AudioI2C_Send_cpu2(0x78,0x7f);		
	AudioI2C_Send_cpu2(0x79,0xfc);		

	//
	//	Enable all Outputs		
	//

	AudioI2C_Send_cpu2(5,0x91);
	AudioI2C_Send_cpu2(11,0x85);		//NDAC = 4, MDAC = 4, dividers powered on
	AudioI2C_Send_cpu2(12,0x83);
	AudioI2C_Send_cpu2(0x63,0xb6);
	AudioI2C_Send_cpu2(0,0x01);
	AudioI2C_Send_cpu2(30,0x03);		
	AudioI2C_Send_cpu2(32,0x86);			//DATA sheet says this should be 8 not 5
	AudioI2C_Send_cpu2(40,0x06);			//DATA sheet says this should be 8 not 5
	AudioI2C_Send_cpu2(0,0);
	//data = AudioI2C_Get_cpu2(37);

	AudioI2C_Send_cpu2(39,0);

	//
	// Configure SysTick for a 100Hz interrupt.  The FatFs driver wants a 10 ms
	// tick.
	//

	ROM_SysTickPeriodSet(ROM_SysCtlClockGet() / 100);
	// ROM_SysTickEnable();
	// ROM_SysTickIntEnable();

	//
	// Enable Interrupts
	//

	//ROM_IntMasterEnable();
	//ROM_SysCtlDeepSleep();
	//  ROM_SysCtlReset();
	//
	//SysCtlDelay(ROM_SysCtlClockGet()/5);
	//SysCtlDelay(ROM_SysCtlClockGet()/5);
}
#endif

#ifdef cpu2

//****************************************************************************************
// Routine:  get_audio(char *filename)
// Input: filename - the filename to read the audio file from
// Output: FRESULT- return the result of trying to get audio.
// Function: Opens the audio file and reads the audio data.
//****************************************************************************************
FRESULT get_audio(char *filename)
{
	int trial = 0;

	do
	{
		if((currentSoundFile != NULL) && strcmp(currentSoundFile, filename)) // if a different sound file is open, close it first.
		{
			f_close(&g_sAudioFileObject);
			currentSoundFile = NULL;
		}

		if(log_file)
		{
			f_close(&g_sLogFileObject2);
			log_file = false;
		}

		if(readingWriting == true) //if we are in the middle of reading or writing to a file, we want to first close it
		{
			f_close(&g_sReadWriteFileObject1);
			readingWriting = false;
		}

		if(currentSoundFile == NULL) // if a file isn't open yet.
		{
			fresult = f_open(&g_sAudioFileObject, filename, FA_READ);
			strcpy(currentSoundFile, filename);

			if(fresult != FR_OK)
			{
				trial++;
				file_close=1;
				continue;
			}

			file_close=1;
		}

		fresult = f_read(&g_sAudioFileObject, audio,44,&usBytesRead);//get rid of header

		if(fresult != FR_OK)
		{
			trial++;
			continue;
		}

		fresult = f_read(&g_sAudioFileObject, audio,512,&usBytesRead);//read the first audio data

		if(fresult != FR_OK)
		{
			trial++;
		}
		else
		{
			break;
		}
	}while(trial<2);

	return fresult;
}

// a wrapper, to add the option of giving choosing a sound in cpu2
void loudspeaker_cpu2()
{
	loudspeaker_cpu2_param(-1);
}

//*****************************************************************************
// Routine:  loudspeaker_cpu2()
// Input: none
// Output: none
// Function:Opening the audio file and sounding the audio
//*****************************************************************************
void loudspeaker_cpu2_param(int param)
{  
	int p;

	if(param == -1)
	{
		RingBufRead(&sRingBuf, pcData,1);
		p=(int) pcData[0];
	}
	else
		p = param;

	EOF_buffer1=0;
	EOF_buffer2=0;	

	char *icons[30] =
	{
			"01_",    // 0x00 - SYSTEM_STATE_PLACE_HEAD_ON_HEADREST
			"02_",    // 0x01 - SYSTEM_STATE_PRESS_GREEN_IF_NO_RESPONSE, SYSTEM_STATE_MONITORING_PRESS_GREEN, SYSTEM_STATE_PRESS_GREEN_AGAIN
			"03_",    // 0x02 - SYSTEM_STATE_CHECK_PADS
			"04_",    // 0x03 - SYSTEM_STATE_ANALYSIS
			"05_",    // 0x04 - SYSTEM_STATE_PLACE_MASK
			"06_",    // 0x05 - SYSTEM_STATE_PLACE_ECG_PADS
			"07_",    // 0x06 - SYSTEM_STATE_PLACE_O2_PROBE
			"07_",    // 0x07 - not used
			"08_",    // 0x08 - SYSTEM_STATE_PRESS_RED
			"09_",    // 0x09 - SYSTEM_STATE_CHECK_PROBE
			"10_",    // 0x0A - SYSTEM_STATE_CHECK_ECG_STICKERS
			"11_",    // 0x0B - SYSTEM_STATE_CHECK_MASK
			"12_",    // 0x0C - SYSTEM_STATE_START_CPR
			"13_",    // 0x0D - SYSTEM_STATE_CPR_HAND_LOCATION
			"14_",    // 0x0E - SYSTEM_STATE_CPR_START_PUSH
			"100bpm", // 0x0F - SYSTEM_STATE_CPR_PUSH
			"16_",    // 0x10 - SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN
			"17_",    // 0x11 - SYSTEM_STATE_REMOVE_SECRETION
			"18_",    // 0x12 - Low battery
			"19_",    // 0x13 - Low Oxygen
			"20_",    // 0x14 - Remove face mask_
			"21_",    // 0x15 - SYSTEM_STATE_SHOCK_DELIVERED
			"ring",   // 0x16 - Beep 3 times
			"25_",    // 0x17 - SYSTEM_STATE_PAY_ATTENTION_CPR
			"plugin", // 0x18 - Plugin to charger
			"warning",// 0x19 - Warning in advanced screen
			"26_",    // 0x1A - SYSTEM_STATE_STOP_CPR
			"27_",    // 0x1B - SYSTEM_STATE_NO_SHOCK
			"28_",	  // 0x1C - SYSTEM_STATE_CHARGING_DONT_TOUCH
			"endcall" // 0x1D - Sound for the end of a phone call
	};

	char filename[20];
	strcpy(filename, icons[p]);
	if(p != 0x0f && p != 0x16 && p != 0x18 && p != 0x19 && p != 0x1D)
		strcat(filename, lang ? lang_a : lang_b);
	strcat(filename, ".wav");

	fresult = get_audio(filename);

	//if failed to read audio data
	if(fresult != FR_OK)
	{
		return;
	}

#ifdef ENABLE_WATCHDOG
	watch_dog_counter += 3000; //add 6 seconds (500 times in a second)
#endif // ENABLE_WATCHDOG

	buffer_pointer=0; //run between 0 to 1025 in SSI_water_mark int

	while(buffer_pointer<8)//start to send ssi and enter to int
	{	
		sound = audio[buffer_pointer++];
		sound = sound+256*audio[buffer_pointer++];

		SSIDataPut(SSI2_BASE,sound);
		SSIDataPut(SSI2_BASE,0x00);
	}

	buffer_2_empty=1;
	SSIIntEnable(SSI2_BASE,SSI_TXFF);
	IntEnable(INT_SSI2);

	//this is a workaround, shouldn't happen, but better this then nothing....
	if(comm_state == 0)
	{
		comm_state = 1;
		door_status = 1;
	}
}
#endif

#ifdef cpu2
#define RETRY_TIMES 3

#ifdef DEBUG_CPU2_PRINT
void DebugPrint_cpu2(char *str)
{
	int i = 0;
	SSIDataPut(SSI3_BASE, 0xFB);
	while(str[i] != '\0')
	{
		SSIDataPut(SSI3_BASE, str[i]);
		i++;
	}
	SSIDataPut(SSI3_BASE, 0xFC);
}
#endif

#endif //CPU2

//*****************************************************************************
// Routine:  main(void)
// Input: none
// Output: none
// Function:main for cpu1 and cpu2
//*****************************************************************************
main(void)
{
	// WIP BOOT LOADER
	//ROM_UARTDisable(UART0_BASE);
	//HWREG(NVIC_DIS0) = 0x0;
	//HWREG(NVIC_DIS1) = 0x0;
	//UARTEnable(UART0_BASE);
	//DebugPrint("START\0");
	//
	//************************** INITIALIZATION  *************************
	//
	// Enable lazy stacking for interrupt handlers.  This allows floating-point
	// instructions to be used within interrupt handlers, but at the expense of
	// extra stack usage.
	//
	ROM_FPULazyStackingEnable();

	// Set the clocking to run directly from the crystal.
	ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5  | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ |
			SYSCTL_OSC_MAIN);

	//initialize the ring buffers used for passing data from cpu1 to cpu2 and cpu3.
	InitRingBuffers();

#ifdef	cpu2

	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
	GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_7);
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
	GPIOPinTypeGPIOOutput(GPIO_PORTD_BASE, GPIO_PIN_1);

	clock=0;/////when closing it will be false again
	isSaliSoundMuted = 1;

	RingBufInit(&sRingBuf, pcBuffer, sizeof(pcBuffer));
	RingBufInit(&RingBuf_ecg, ecgBuffer, sizeof(ecgBuffer));
	RingBufInit(&RingBuf_ecgfile, ecgBuffer1, sizeof(ecgBuffer1));

	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOH);
	GPIOPinTypeGPIOInput(GPIO_PORTH_BASE, GPIO_PIN_0);
	GPIOPadConfigSet(GPIO_PORTH_BASE, GPIO_PIN_0, GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD_WPU);
	GPIOPinTypeGPIOInput(GPIO_PORTH_BASE, GPIO_PIN_1);
	GPIOPadConfigSet(GPIO_PORTH_BASE, GPIO_PIN_1, GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD_WPU);
	GPIOPinTypeGPIOInput(GPIO_PORTH_BASE, GPIO_PIN_2);
	GPIOPadConfigSet(GPIO_PORTH_BASE, GPIO_PIN_2, GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD_WPU);

	//ssi3 connecion between 2 prossesor
	ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOK);
	GPIOPinConfigure(GPIO_PK0_SSI3CLK);
	GPIOPinConfigure(GPIO_PK1_SSI3FSS);
	GPIOPinConfigure(GPIO_PK2_SSI3RX);
	GPIOPinConfigure(GPIO_PK3_SSI3TX);
	SysCtlPeripheralEnable(SYSCTL_PERIPH_SSI3);

	GPIOPinTypeSSI(GPIO_PORTK_BASE, SSI3_CLK | SSI3_RX |SSI3_TX |SSI3_FSS );

	SSIDisable(SSI3_BASE);
	SSIConfigSetExpClk(SSI3_BASE, SysCtlClockGet(), SSI_FRF_MOTO_MODE_1,SSI_MODE_SLAVE, 1500000, 8);

	SSIEnable(SSI3_BASE);

	pulData=0;

	// Enable the UART.
	ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
	ROM_GPIOPinConfigure(GPIO_PB1_U1TX);
	ROM_GPIOPinConfigure(GPIO_PB0_U1RX);
	ROM_GPIOPinTypeUART(GPIO_PORTB_BASE, GPIO_PIN_1 | GPIO_PIN_0);
	ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART1);
	UARTStdioInit(1);
	//
	// Enable the UART.
	//
	UARTEnable(UART1_BASE);
	UARTEchoSet(false);

	ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
	HWREG(GPIO_PORTD_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY_DD;
	HWREG(GPIO_PORTD_BASE + GPIO_O_CR) = 0xff;
	HWREG(GPIO_PORTD_BASE + GPIO_O_AFSEL) =0;

	ROM_GPIOPinTypeUART(GPIO_PORTD_BASE, GPIO_PIN_6 | GPIO_PIN_7);

	ROM_GPIOPinConfigure(GPIO_PD7_U2TX);
	ROM_GPIOPinConfigure(GPIO_PD6_U2RX);

	ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART2);
	ROM_UARTConfigSetExpClk(UART2_BASE, ROM_SysCtlClockGet(), 115200,
			(UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
					UART_CONFIG_PAR_NONE));
	//
	// Enable the UART interrupt.

	UARTFIFOEnable(UART2_BASE);

	UARTEnable(UART2_BASE);

	ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);

	ROM_GPIOPinConfigure(GPIO_PE5_U5TX);
	ROM_GPIOPinConfigure(GPIO_PE4_U5RX);
	ROM_GPIOPinTypeUART(GPIO_PORTE_BASE, GPIO_PIN_4 | GPIO_PIN_5);
	ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART5);

	ROM_UARTConfigSetExpClk(UART5_BASE, ROM_SysCtlClockGet(), 115200,
			(UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
					UART_CONFIG_PAR_NONE));

	UARTEnable(UART5_BASE);
	UARTEchoSet(false);

	ecgsendflag=0;

	ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);

	// Configure the two 32-bit periodic timers.
	//
	ROM_TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC);
	ROM_TimerLoadSet(TIMER0_BASE, TIMER_A, ROM_SysCtlClockGet()/500);//100//200
	ROM_IntEnable(INT_TIMER0A);
	ROM_TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
	ROM_TimerEnable(TIMER0_BASE, TIMER_A);

	// Get reset cause to see if it was by the watchdog
	unsigned long reset_cause = SysCtlResetCauseGet();

	if((reset_cause & SYSCTL_CAUSE_WDOG) == SYSCTL_CAUSE_WDOG)
	{
		was_reset_by_wdog = true;
	}
	else if((reset_cause & SYSCTL_CAUSE_SW) == SYSCTL_CAUSE_SW)
	{
		was_reset_by_software = true;
	}
	else
	{
		// Do nothing
	}

	SysCtlResetCauseClear(reset_cause);

#ifdef ENABLE_WATCHDOG
	// Enable the watchdog.
	ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_WDOG0);
	ROM_IntEnable(INT_WATCHDOG);
	ROM_WatchdogReloadSet(WATCHDOG0_BASE, ROM_SysCtlClockGet());
	ROM_WatchdogResetEnable(WATCHDOG0_BASE);
	ROM_WatchdogEnable(WATCHDOG0_BASE);
	WatchdogStallEnable(WATCHDOG0_BASE);

	watch_dog_counter = 500 * 10; // 10 seconds (500 times in a second)
#endif // ENABLE_WATCHDOG

	g_bFeedWatchdog = true;

	ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER1);

	ROM_TimerConfigure(TIMER1_BASE, TIMER_CFG_PERIODIC);
	ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, ROM_SysCtlClockGet()/500);//100//200
	ROM_IntEnable(INT_TIMER1A);
	ROM_TimerIntEnable(TIMER1_BASE, TIMER_TIMA_TIMEOUT);
	ROM_TimerEnable(TIMER1_BASE, TIMER_A);

	Audio_init_cpu2();

	// We are finished initialization  Beginning Background Processing using timeslice
	fresult=f_mount(0, &g_sFatFs_cpu2);

	if(fresult != FR_OK)
	{
	}

	packet_cntr=7;

	MGW830Config();
	dhr[0]=0;
	dhr[1]=0;
	dhr[2]=0;

	timeslice1=0;
	timeslice=0;
	int i;
	int k;
	int lm;

	ROM_IntMasterEnable();
	GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_7, 0x00);
	GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_1, 0x00);
	modem_watchdog_flag = 0;

	for (k = 0 ; k < 20; k++)
	{
		Emergency_Num[k] = 0;
	}

	if(read_file("emergnum.txt", Emergency_Num))
	{
		if(Emergency_Num[5]) //check that we have a value in the sixth place in order to check that a number exists in the file. basic dummy check...
		{
			EmergencyNumExists = 1;
		}
	}

	for(k = 0 ; k < 10; k++)
	{
		read_lang[k] = 0;
	}

	if(read_file("lang.txt", read_lang))
	{
		lang_a[0] = read_lang[0];
		lang_a[1] = read_lang[1];
		lang_b[0] = read_lang[3];
		lang_b[1] = read_lang[4];
	}

	lang=1;// change to default lang

	if(was_reset_by_wdog == true)
	{
		ROM_UARTCharPut(UART2_BASE, 0x10);
	}
	else if(was_reset_by_software == true)
	{
		ROM_UARTCharPut(UART2_BASE, 0x11);
	}

	for(k = 0 ; k < 40; k++)
	{
		chosen_apn[k] = 0;
	}

	for(k = 0 ; k < 20; k++)
	{
		nw_country[k] = 0;
	}

	f_opendir(&dir, "APNS");	/* Open the directory */

	if(fresult != FR_OK)
	{
	}

	get_chosen_apns(); // try to get all of the apns from the sd card.

	while(1) //when every thing connect
	{
		modem_watchdog_cnt = MODEM_WATCHDOG_TIME;

		{///wake up
			ROM_SysTickEnable();
			ROM_SysTickIntEnable();

			lm=0;
			rel1=0;
			lang_ch1=0;

			ROM_IntEnable(INT_UART2);
			ROM_UARTIntEnable(UART2_BASE, UART_INT_RX | UART_INT_RT);

			// while(1);
			IntPrioritySet(INT_SSI2, 0x0);//set ssi2 to highest priority
			IntPrioritySet(INT_TIMER0A, 0x20); //set T0 to a lower priority

#ifndef NO_SIM
			Init_m10_cpu2();
			testModem=0;

			// try to register the machine when turned on
			if(first_time == 0 && comm_status_cpu2)
			{
				first_time = 1;
				send_register_req();
			}

			// In case comm didn't go up in time for the first ATP.
			if(send_ATP_flag == true && comm_status_cpu2 == true)
			{
				send_ATP_result(atp_result_cpu2);
				send_ATP_flag = false;
			}
#endif

#ifdef WIP_transfer_file
			usprintf(CPU2_transfer_file_name,"hello.exe");
			CPU2_transfer_file_size = 11035;
			CPU2_transfering_file = true;
#endif
		}
#ifdef CPU2_SLEEP
		// Sali got picked up from wall mount
		if(sali_was_on_wall_cpu2 && !sali_on_wall_cpu2)
		{
#ifndef NO_SIM
			//send_getUpdate_req();
#endif
			sali_was_on_wall_cpu2 = false;
			send_mount_state(0);
		}

		// Sali just got put on wall mount
		if(!sali_was_on_wall_cpu2 && sali_on_wall_cpu2)
		{
			sali_was_on_wall_cpu2 = true;
			send_mount_state(1);
		}

		while(reset==0 || sali_on_wall_cpu2)//sleep_mode
		{
			// Turn off leds
			GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_7 ,0x00);
			GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_1 ,0x00);

			ROM_UARTCharPut(UART5_BASE,'r');

			if(dec==0)
			{
				if((data = 0xff&ROM_UARTCharGetNonBlocking(UART2_BASE)) == 0x26)
					dec=1;
				ROM_UARTCharPut(UART5_BASE,'l');
			}
			if(dec==1)
			{
				if((data = 0xff & ROM_UARTCharGetNonBlocking(UART2_BASE)) == 0x88)
				{
					reset = 1;//waking from sleep from cpu1
				}
				else
				{
					dec=0;
				}
			}
			if(lm==0)//sleeping after been wake
			{
				clock=0;
				dec=0;
				ecgsendflag=0;
				ST_flag=0;
				HR_flag=0;
				spo2msg_flag=0;
				dspo2rate_flag=0;
				dspo2value_flag=0;
				avg_flag=0;
				avg_flag_1=0;
				ST_flag_1=0;
				HR_flag_1=0;
				filename=0;
				spo2msg_flag_1=0;
				dspo2rate_flag_1=0;
				dspo2value_flag_1=0;
				// first=1;
				lm=1;
			}
		}

#endif //CPU2_SLEEP
		while(1)//(reset==1)///waking up
		{
#ifdef ENABLE_WATCHDOG
			watch_dog_counter = 15 * 500; //15 seconds (500 times in a second)
#endif // ENABLE_WATCHDOG

			// Sali got picked up from wall mount
			if(sali_was_on_wall_cpu2 && !sali_on_wall_cpu2)
			{
#ifdef ENABLE_WATCHDOG
				watch_dog_counter += 2500; // add 5 seconds
#endif // ENABLE_WATCHDOG

				sali_was_on_wall_cpu2 = false;
				send_mount_state(0);
			}

			// Sali just got put on wall mount
			if(!sali_was_on_wall_cpu2 && sali_on_wall_cpu2)
			{
#ifdef ENABLE_WATCHDOG
				watch_dog_counter += 2500; // add 5 seconds
#endif // ENABLE_WATCHDOG
				sali_was_on_wall_cpu2 = true;
				send_mount_state(1);
			}

			if(cpu2_new_atp == true)
			{
				getClockFromCellular();

				if(comm_status_cpu2 == true)
				{
					watch_dog_counter += 2500; // add 5 seconds

					send_ATP_result(atp_result_cpu2);
				}
				else
				{
					send_ATP_flag = true;
				}
				cpu2_new_atp = false;
			}

			if(set_speaker_volume_flag == true)
			{
				if(!volume_status(speaker_volume_flag))
				{
					testModem++;
				}
				else
				{
					testModem=0;
					set_speaker_volume_flag = false;
				}

				if(testModem==10)
				{
					Init_m10_cpu2();
					testModem = 0;
				}
			}

			if(comm_state == 0 && comm_status_cpu2 == true) //shouldn't happen, but still....
			{
				comm_state = 1;
			}

			if(comm_state == 1)//door is opened
			{
#ifndef NO_SIM
				door_status = 1;
				comm_state = 4;//the modem is okay, start sending

				for(i=0; i < 1000; i++)
				{
					ecg_wave[i] = '0';
				}
				ecg_wave[1000] = '\0';
#else
				comm_state = -1;
#endif	
				call_activated = 0;
				advanced_press_timer = 0;
				run_advanced_timer = 0;
				EmergencyCallRequested = 0;
				sendData = 0;
			}
			// Connection is down, restart modem.
			if(comm_state == 2)
			{
			}
#ifdef CPU2_SLEEP
			// Enter sleep mode
			if(comm_state == 3)
			{
				if(isSleeping_CPU2 == false)
				{
					isSleeping_CPU2 = true;
				}
			}
#endif
			//start sending
			if(comm_state == 4)
			{
				if(!set_incoming_calls())
				{
					testModem++;
				}
				else
				{
					testModem = 0;
				}

				if(testModem == 10)
				{
					Init_m10_cpu2();
					testModem=0;
				}

				if(modem_call_status_check == true)
				{
					if(!checkCallStatus())
					{
						testModem++;
					}
					else
					{
						testModem = 0;
						modem_call_status_check = false;
					}

					if(testModem == 10)
					{
						Init_m10_cpu2();
						testModem=0;
					}
				}

				isSleeping_CPU2 = false;

				if(ecgsendflag)
				{
					for(i=0; i < 1000; i = i + 2)
					{
						char c = RingBufReadOne(&RingBuf_ecg);
						ecg_wave[i] = c;
						c = RingBufReadOne(&RingBuf_ecg);
						ecg_wave[i+1] = c;
					}

					ecg_wave[1000] = '\0';

					//saving_log("got the ECG");

					if(comm_status_cpu2)
					{
						if((!call_activated || sendData) && EmergencyNumExists && EmergencyCallRequested)
						{
							callEmergencyCenter(Emergency_Num);

							if(call_activated)
							{
								EmergencyCallRequested = 0;
								sendData = 1;
							}
						}

						if(!EmergencyNumExists || sendData || callInProgress)
						{
							//saving_log("Sending Emergency Incident");
#ifdef ENABLE_WATCHDOG
							watch_dog_counter += 2500; // add 5 seconds
#endif //ENABLE_WATCHDOG
							send_EmergencyIncident();
							//saving_log("finished Sending Emergency Incident");
						}
					}
					ecgsendflag = 0;
				}
			}
		}
	}

#endif

#ifdef cpu1
	{
		vf_detected_timer = 200 * 10; //ten sceonds.
		vf_detected_counter = 0; // amount of times detected.

		high_heart_rate_timer = 200 * 15; //fifteen seconds.
		high_heart_rate_detected_counter = 0;

		low_heart_rate_timer = 200 * 15; //fifteen seconds.
		low_heart_rate_detected_counter = 0;

		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
		HWREG(GPIO_PORTD_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY_DD;
		HWREG(GPIO_PORTD_BASE + GPIO_O_CR) = 0xff;
		HWREG(GPIO_PORTD_BASE + GPIO_O_AFSEL) =0;
///		ROM_GPIOPinConfigure(GPIO_PD7_U2TX);
///		ROM_GPIOPinConfigure(GPIO_PD6_U2RX);
		ROM_GPIOPinTypeUART(GPIO_PORTD_BASE, GPIO_PIN_6 | GPIO_PIN_7);
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART2);
		ROM_UARTConfigSetExpClk(UART2_BASE, ROM_SysCtlClockGet(), 115200,
				(UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
						UART_CONFIG_PAR_NONE));
		UARTFIFOEnable(UART2_BASE);

		UARTEnable(UART2_BASE);
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOH);
		GPIOPinTypeGPIOOutput(GPIO_PORTH_BASE, GPIO_PIN_0); 
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
		GPIOPinTypeGPIOOutput(GPIO_PORTD_BASE, GPIO_PIN_0);

		SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
		GPIOPinTypeGPIOInput(GPIO_PORTE_BASE, GPIO_PIN_7);//INT FOR RESET

		GPIOPinIntClear(GPIO_PORTE_BASE, GPIO_PIN_7 );
		GPIOIntTypeSet(GPIO_PORTE_BASE,GPIO_PIN_7 , GPIO_HIGH_LEVEL);
		GPIOPinTypeGPIOInput(GPIO_PORTE_BASE, GPIO_PIN_6);//INT FOR RESET

		GPIOPinIntClear(GPIO_PORTE_BASE, GPIO_PIN_6 );
		GPIOIntTypeSet(GPIO_PORTE_BASE,GPIO_PIN_6 , GPIO_LOW_LEVEL);

		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
		//for debbuging
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
		ROM_GPIOPinConfigure(GPIO_PA0_U0RX);
		ROM_GPIOPinConfigure(GPIO_PA1_U0TX);
		ROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);

		//  ROM_UARTConfigSetExpClk(UART0_BASE, ROM_SysCtlClockGet(), 115200,
		//      (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
		//      UART_CONFIG_PAR_NONE));
		//   UARTEnable(UART0_BASE);
		UARTStdioInit(0);

		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC); ///For the AED
		ROM_GPIOPinConfigure(GPIO_PC5_U4TX);
        ROM_GPIOPinConfigure(GPIO_PC4_U4TX);
		ROM_GPIOPinTypeUART(GPIO_PORTC_BASE, GPIO_PIN_4 | GPIO_PIN_5);
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART4);
		ROM_UARTConfigSetExpClk(UART4_BASE, ROM_SysCtlClockGet(), 115200,
				(UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
						UART_CONFIG_PAR_NONE));
		ROM_UARTIntEnable(UART4_BASE, UART_INT_RX | UART_INT_RT);

		MGW830Config();
		dhr[0]=0;
		dhr[1]=0;
		dhr[2]=0;
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);
		GPIOPinTypeUART(GPIO_PORTC_BASE, GPIO_PIN_6 | GPIO_PIN_7);
///		GPIOPinConfigure(GPIO_PC6_U3RX);
///		GPIOPinConfigure( GPIO_PC7_U3TX);

		//
		// Configure the UART for 115,200, 8-N-1 operation.
		//
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART3);
		ROM_UARTConfigSetExpClk(UART3_BASE, ROM_SysCtlClockGet(), 115200,
				(UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
						UART_CONFIG_PAR_NONE));
		// Enable the UART interrupt.
		//

		UARTFIFOEnable(UART3_BASE);

		UARTEnable(UART3_BASE);


		//ssi3 connecion between 2 prossesor
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOK);
		SysCtlPeripheralEnable(SYSCTL_PERIPH_SSI3);
		GPIOPinTypeSSI(GPIO_PORTK_BASE, SSI3_CLK | SSI3_RX |SSI3_TX |SSI3_FSS );
		GPIOPinConfigure(GPIO_PK0_SSI3CLK);
		GPIOPinConfigure(GPIO_PK1_SSI3FSS);
		GPIOPinConfigure(GPIO_PK2_SSI3RX);
		GPIOPinConfigure(GPIO_PK3_SSI3TX);
	    GPIOPinConfigure(GPIO_PF2_SSI1CLK);
	    GPIOPinConfigure(GPIO_PF3_SSI1FSS);
	    GPIOPinConfigure(GPIO_PF0_SSI1RX);
	    GPIOPinConfigure(GPIO_PF1_SSI1TX);
	#
		SSIDisable(SSI3_BASE);
		SSIConfigSetExpClk(SSI3_BASE, SysCtlClockGet(), SSI_FRF_MOTO_MODE_1,SSI_MODE_MASTER, 1500000, 8);
		SSIEnable(SSI3_BASE);

		//Timer1 configure for button input
		//
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER1);
		ROM_TimerConfigure(TIMER1_BASE, TIMER_CFG_PERIODIC);
		ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, ROM_SysCtlClockGet()/200);//100//50
		ROM_IntEnable(INT_TIMER1A);

		ROM_TimerEnable(TIMER1_BASE, TIMER_A);


		//input botton to main cpu
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
		GPIOPinTypeGPIOInput(GPIO_PORTB_BASE,  GPIO_PIN_4);
		GPIOPinIntClear(GPIO_PORTB_BASE,GPIO_PIN_4);
		GPIOIntTypeSet(GPIO_PORTB_BASE, GPIO_PIN_4,GPIO_FALLING_EDGE);
		GPIOPinIntEnable(GPIO_PORTB_BASE, GPIO_PIN_4);

		GPIOPinTypeGPIOInput(GPIO_PORTB_BASE,  GPIO_PIN_5);
		GPIOPinIntClear(GPIO_PORTB_BASE,GPIO_PIN_5);
		GPIOIntTypeSet(GPIO_PORTB_BASE, GPIO_PIN_5, GPIO_LOW_LEVEL);
		GPIOPinIntEnable(GPIO_PORTB_BASE, GPIO_PIN_5);


		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
		ROM_GPIOPinConfigure(GPIO_PE5_U5TX);
		ROM_GPIOPinConfigure(GPIO_PE4_U5RX);
		ROM_GPIOPinTypeUART(GPIO_PORTE_BASE, GPIO_PIN_5 | GPIO_PIN_4);
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART5);
		ROM_UARTConfigSetExpClk(UART5_BASE, ROM_SysCtlClockGet(), 115200,
				(UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
						UART_CONFIG_PAR_NONE));
		UARTFIFOEnable(UART5_BASE);
		UARTEnable(UART5_BASE);

		//Timer2 for ADC  cpu1
		//
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER2);
		ROM_TimerConfigure(TIMER2_BASE, TIMER_CFG_PERIODIC);
		TimerConfigure(TIMER2_BASE, (TIMER_CFG_A_PERIODIC |TIMER_CFG_B_PERIODIC));//TIMER_CFG_16_BIT_PAIR |
		TimerLoadSet(TIMER2_BASE, TIMER_A, (SysCtlClockGet()/50)); //if just clock set so every 1 sec 																     //if /50 every 20 mS
		TimerControlTrigger(TIMER2_BASE, TIMER_A, true);

		//
		// Enable the timer.
		//
		/// TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
		TimerEnable(TIMER2_BASE, TIMER_A);
		// Enable the peripherals used by the data collection.
		//

		SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);

		//
		// Configure the ADC sample sequence.
		//
		SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
		GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_0| GPIO_PIN_1| GPIO_PIN_2| GPIO_PIN_3);

		//   ADCHardwareOversampleConfigure(ADC_BASE, 4);
		ADCSequenceConfigure(ADC0_BASE, 2, ADC_TRIGGER_TIMER, 0);
		ADCSequenceStepConfigure(ADC0_BASE, 2, 0, ADC_CTL_CH0);
		ADCSequenceStepConfigure(ADC0_BASE, 2, 1, ADC_CTL_CH1);
		ADCSequenceStepConfigure(ADC0_BASE, 2, 2, ADC_CTL_CH2);
		ADCSequenceStepConfigure(ADC0_BASE, 2, 3, ADC_CTL_CH3 |  ADC_CTL_END | ADC_CTL_IE);
		ADCSequenceEnable(ADC0_BASE, 2);

		// Enable 64x hardware averaging
		ADCHardwareOversampleConfigure(ADC0_BASE, 64);

		//
		// Enable the ADC sample sequence interrupt.
		//

		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
		GPIOPinTypeGPIOOutput(GPIO_PORTD_BASE, GPIO_PIN_2);
		GPIOPinTypeGPIOOutput(GPIO_PORTD_BASE, GPIO_PIN_3);

		//limit motor pins


		// ROM_SysCtlReset();

		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART6);
		ROM_GPIOPinConfigure(GPIO_PD5_U6TX);
		ROM_GPIOPinConfigure(GPIO_PD4_U6RX);
		ROM_GPIOPinTypeUART(GPIO_PORTD_BASE, GPIO_PIN_5 | GPIO_PIN_4);

		ROM_UARTConfigSetExpClk(UART6_BASE, ROM_SysCtlClockGet(), 115200,
				(UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
						UART_CONFIG_PAR_NONE));

		UARTEnable(UART6_BASE);
		UARTEchoSet(false);
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_HIBERNATE);//enabling hibernate RTC
		HibernateEnableExpClk(ROM_SysCtlClockGet());
		HibernateClockSelect(HIBERNATE_CLOCK_SEL_RAW);
		HibernateIntRegister(RTCMATCHIntHandler);

		//ROM_HibernateRTCSet(0);
		// ulSeconds = HibernateRTCGet();
		// ulSeconds+=10;
		//  HibernateRTCMatch0Set(ulSeconds);
		// HibernateWakeSet(HIBERNATE_WAKE_PIN);
		//HibernateIntEnable(HIBERNATE_INT_PIN_WAKE);
		// ROM_HibernateRTCEnable();
		//HibernateIntEnable(HIBERNATE_INT_PIN_WAKE);
		//   ROM_HibernateRTCEnable();
#ifdef develop
		// HibernateRTCMatch0Set(ulSeconds);
		//  HibernateIntEnable(HIBERNATE_INT_RTC_MATCH_0);

		//   ROM_HibernateRTCEnable();
#endif
		//in order to calc breath rate we have to init the Br buffer
		char t;

		for(t=0;t<80;t++)
		{
			br_buffer[t]=0;
		}
		br_buffer[0]=3001;

		////to main cpu1_motor_oxygen_balloon
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
		GPIOPinTypeGPIOOutput(GPIO_PORTD_BASE, GPIO_PIN_0);
		GPIOPinTypeGPIOOutput(GPIO_PORTD_BASE, GPIO_PIN_2);
		GPIOPinTypeGPIOOutput(GPIO_PORTD_BASE, GPIO_PIN_3);
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOH);
		GPIOPinTypeGPIOOutput(GPIO_PORTH_BASE, GPIO_PIN_0);
		//sensor oxygen pins output
		GPIOPinTypeGPIOOutput(GPIO_PORTH_BASE, GPIO_PIN_1);
		GPIOPinTypeGPIOOutput(GPIO_PORTH_BASE, GPIO_PIN_2);
		//ring buffer

		// Init FAT system
		fresult=f_mount(0, &g_sFatFs_cpu1);
		if(fresult != FR_OK) DebugPrintWithTime("Failed to initialize fat fs\r\n");

		//
		// Initialize the ring buffer.
		//
		GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_2 ,0x00);
		GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0x00);
		RingBufInit(&sRingBuf, pcBuffer, sizeof(pcBuffer));
		RingBufInit(&sRingBuf_adv, pcBuffer_adv, sizeof(pcBuffer_adv));
		RingBufInit(&sRingBuf_adv1, pcBuffer_adv, sizeof(pcBuffer_adv));

		//INT for openning the door
		GPIOPortIntRegister(GPIO_PORTE_BASE,GPIOE1IntHandler);
		IntEnable(INT_GPIOE);
		GPIOPinIntEnable(GPIO_PORTE_BASE, GPIO_PIN_6 );
		GPIOPinIntEnable(GPIO_PORTE_BASE, GPIO_PIN_7 );
		ROM_IntMasterEnable();

		//INT for battery charge
		GPIOPortIntRegister(GPIO_PORTB_BASE,GPIOB1IntHandler);
		IntEnable(INT_GPIOB);
		GPIOPinIntEnable(GPIO_PORTB_BASE, GPIO_PIN_4 );
		GPIOPinIntEnable(GPIO_PORTB_BASE, GPIO_PIN_5 );
		ROM_IntMasterEnable();

		//DebugPrint("Starting Sali \0");
		//send_getUpdate_req();

		int init = 1;

		while(1)
		{
			//////////////////////////////////////////////////////////////
			// Go to sleep
			//////////////////////////////////////////////////////////////
			if(reset1 == sleep)
			{
				if(sleep_ATP_timer == -1)
				{
					system_status = SYSTEM_STATUS_SLEEP;
					DebugPrintWithTime("Going to sleep\r\n");
					sleep_ATP_timer = 200 * 60 * 60 * 12;
				}
				if(sleep_ATP_timer == 0)
				{
					//reset1 = self_test;
					sleep_ATP_timer = -1;
				}
				/*
				DebugPrint("Going to sleep \0");

				RingBufFlush(&sRingBuf);
				RingBufFlush(&sRingBuf_adv1);
				RingBufFlush(&sRingBuf_adv);
				ROM_IntDisable(INT_UART3);

				SysCtlDelay(10000000);
				GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_1 ,oxygen_level[0][0]);
				GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_2 ,oxygen_level[0][1]);

				//sending cpu 2 to go to sleep
				ROM_UARTCharPut(UART2_BASE,0x27);
				ROM_UARTCharPut(UART2_BASE,0x87);
				ROM_UARTCharPut(UART5_BASE,0xf0);

				if(a==1)///closing the clyinder 
				{
					GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_0 ,0xff);
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_0 ,0x00);
					SysCtlDelay(ROM_SysCtlClockGet());
					SysCtlDelay(ROM_SysCtlClockGet());
					SysCtlDelay(ROM_SysCtlClockGet());
					SysCtlDelay(ROM_SysCtlClockGet());
					SysCtlDelay(ROM_SysCtlClockGet());
					SysCtlDelay(ROM_SysCtlClockGet()/2);
					/// SysCtlDelay(ROM_SysCtlClockGet());
					GPIOPinWrite(GPIO_PORTH_BASE,GPIO_PIN_0 ,0x00);
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_0 ,0x00);
					a=0;
				}


				//ROM_IntEnable(INT_UART2);    
				//ROM_UARTIntEnable(UART2_BASE, UART_INT_RX  ); 
				SysCtlPeripheralSleepEnable(SYSCTL_PERIPH_UART2);
				SysCtlPeripheralSleepEnable(SYSCTL_PERIPH_GPIOE);

				//Going to sleep
				//  ROM_UARTCharPut(UART0_BASE,0x09);
				SysCtlDelay(10000000);
				SysCtlPeripheralSleepEnable(SYSCTL_PERIPH_HIBERNATE);
				ROM_SysCtlPeripheralClockGating(true);
				ROM_SysCtlSleep();
				SysCtlDelay(10000000);
				SysCtlDelay(8000000);

				///waking cpu2 and cpu3 from sleep
				//ROM_UARTCharPut(UART2_BASE,0x26);
				//ROM_UARTCharPut(UART2_BASE,0x88);
				//ROM_UARTCharPut(UART5_BASE,0xf1);
				 */
			}

			//////////////////////////////////////////////////////////////
			// Run self test
			//////////////////////////////////////////////////////////////
			if(reset1 == self_test)
			{
#ifdef develop
				/*
				IntDisable(INT_GPIOE);
				SysCtlDelay(10000000);
				//ROM_IntEnable(INT_UART2);    
				// ROM_UARTIntEnable(UART2_BASE, UART_INT_RX | UART_INT_TX ); 
				ROM_UARTIntEnable(UART3_BASE, UART_INT_RX );
				ROM_IntEnable(INT_UART3); 
				UARTEnable(UART3_BASE); 
				MGW830Send(SETE,2);
				ADCIntEnable(ADC0_BASE, 2);
				IntEnable(INT_ADC2);
				ROM_TimerIntEnable(TIMER1_BASE, TIMER_TIMA_TIMEOUT);
				sum1=0;
				sum2=0;
				count1=0;
				br_state=4;  ///checking avg in order of self test
				while(br_state!=6);
				ROM_UARTCharPut(UART2_BASE,0x26);
				ROM_UARTCharPut(UART2_BASE,0x88);
				SysCtlDelay(10000000);
				h[0]=0x87;

				SSIDataPut(SSI3_BASE,h[0]);
				ROM_UARTCharPut(UART2_BASE,0x27);
				ROM_UARTCharPut(UART2_BASE,0x87);
				ROM_UARTCharPut(UART5_BASE,0xf0);
				reset1=sleep;
				IntEnable(INT_GPIOE);
				 */
#endif
				if(wake_after_self_test)
					reset1 = wake;
				else
					reset1 = sleep;
			}

			if(init)
			{
				DebugPrintWithTime("Initializing...\r\n");
				//GPIOIntTypeSet(GPIO_PORTE_BASE,GPIO_PIN_7 , GPIO_HIGH_LEVEL);
				ROM_IntEnable(INT_UART6);
				ROM_UARTIntEnable(UART6_BASE, UART_INT_RX | UART_INT_RT  );
				ADCIntEnable(ADC0_BASE, 2);
				IntEnable(INT_ADC2);
				ROM_TimerIntEnable(TIMER1_BASE, TIMER_TIMA_TIMEOUT);
				///waking cpu2 and cpu3 from sleep
				ROM_UARTCharPut(UART2_BASE,0x26);
				ROM_UARTCharPut(UART2_BASE,0x88);
				ROM_UARTCharPut(UART5_BASE,0xf1);
				init = 0;
			}
			//////////////////////////////////////////////////////////////
			//Start the procedure
			//////////////////////////////////////////////////////////////
			if(reset1 == wake)
			{
				DebugPrintWithTime("Start the procedure\r\n");
				//door_state = 1;

				if(!isLoadingDone)
				{
					prev_system_state = SYSTEM_STATE_NONE;
					system_state = SYSTEM_STATE_LOADING;
				}
				else
				{
					DebugPrintWithTime("Waking up from hibernation\r\n");
					filename = 0;

					// request for time
					unsigned char time_request[1] ={0x50};
					Write_To_RingBuffer(2, time_request, 1);

					waken_from_sleep = 1;
				}

				rel=1;
				lang_ch=0;
				system_status = SYSTEM_STATUS_NONE;
			}
			while(reset1 == wake)
			{

				if(change_lang_flag && (system_state != SYSTEM_STATE_BACKDOOR1) && (system_state != SYSTEM_STATE_BACKDOOR2) && (system_state != SYSTEM_STATE_ADVANCED_SCREEN))
				{
					// Show the current slide again in different langauge.
					prev_system_state = SYSTEM_STATE_NONE;
					change_lang_flag = 0;
				}

				switch(system_state)
				{
				case SYSTEM_STATE_SLEEP:
				{
					if(prev_system_state != SYSTEM_STATE_SLEEP)
					{
						//DebugPrint("system_state = SYSTEM_STATE_SLEEP ");
						prev_system_state = SYSTEM_STATE_SLEEP;

						sleep_ATP_timer = 200 * 60 * 60 * 12; // ATP once every six hours

						if(first_time_atp)
						{
							sleep_ATP_timer = 200 * 60 * 2;	 // first time, do atp after 2 minutes
						}

						//reset shock delivered count.
						shock_amount = 0;

						//reset the amount of times empty cylinder messages were given.
						cylinderMessageTimes = 0;

						// Set oxygen to 5 lpm
						oxygen_status = OXYGEN_STATUS_5;

						// Put screen to sleep
						unsigned char video_sleep[1] = {0xf0};
						Write_To_RingBuffer(3, video_sleep, 1);

						// Put comm to sleep
						//if(comm_status_cpu1 == 1)
						//{
						DebugPrintWithTime("Putting communication to sleep\r\n");

						unsigned char put_comm_to_sleep[1] ={0xD7};
						Write_To_RingBuffer(2, put_comm_to_sleep, 1);
						//}

						// go back to default lang
						prlan=1;

						unsigned char video_default_lang[2] = {0xf2, prlan};
						Write_To_RingBuffer(3, video_default_lang, 2);

						DebugPrintWithTime("Returning to default langauge\r\n");

						// Mute the volume
						unsigned char mute_vol[2] = {0x82, 100};
						Write_To_RingBuffer(2, mute_vol, 2);


						DebugPrintWithTime("Muting the volume\r\n");

						// Set system status to none
						system_status = SYSTEM_STATUS_NONE;

						// if needed deactivate defibrilator
						if(defib_activated)
						{
							DebugPrintWithTime("Turning off AED\r\n");
#ifdef NEW_BOARD
							GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0xff);//////P10 PIN2-close the M&b
							SysCtlDelay(30000000);
							GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0x00);
#else
							GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_2 ,0x00);//////P10 PIN2-close the M&b
							GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0xff);
							SysCtlDelay(30000000);
							GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_2 ,0xff);
							GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0xff);
#endif /* NEW_BOARD */

							state1 = 0;
							defib_activated = false;
						}
					}
					if(sleep_ATP_timer == 0)
					{
						system_state = SYSTEM_STATE_SELF_TEST;
						first_time_atp = 0;
					}
					if(wake_from_sleep)
					{
						wake_from_sleep = false;
						system_state = SYSTEM_STATE_WAKE;
						//SysCtlDelay(10000000);
					}
					break;
				}
				case SYSTEM_STATE_WAKE:
				{
					if(prev_system_state != SYSTEM_STATE_WAKE)
					{
						//DebugPrint("system_state = SYSTEM_STATE_WAKE \0");
						prev_system_state = SYSTEM_STATE_WAKE;

						first_5_seconds = 200 * 5;
						first_20_seconds = 200 * 20;

						if(comm_status_cpu1)
						{
							create_log_filename();
						}

						log_message("Sali started.");
						DebugPrintWithTime("Waking up\r\n");

						// Wake screen
						ROM_UARTCharPut(UART5_BASE,0xf1);
						SysCtlDelay(5000000);
						ROM_UARTCharPut(UART5_BASE,0xf1);
						SysCtlDelay(5000000);
						ROM_UARTCharPut(UART5_BASE,0xf1);
						SysCtlDelay(5000000);
						ROM_UARTCharPut(UART5_BASE,0xf1);
						SysCtlDelay(5000000);
						ROM_UARTCharPut(UART5_BASE,0xf1);

						// Wake comm with a new time, will start a new case with the server
						if(comm_status_cpu1 == 1)
						{
							DebugPrintWithTime("Restarting communication\r\n");
							filename = 0;

							unsigned char wake_up_comm[1] ={0xD8};
							Write_To_RingBuffer(2, wake_up_comm, 1);
						}

						// Un-mute the volume
						unsigned char unmute_vol[2] = {0x82, 101};
						Write_To_RingBuffer(2, unmute_vol, 2);

						DebugPrintWithTime("Unmuting Volume\r\n");

						wait2 = 0;

						send_langauges();

						system_state = SYSTEM_STATE_PLACE_HEAD_ON_HEADREST;
					}
					break;
				}
				case SYSTEM_STATE_SELF_TEST:
				{
					//DebugPrint("SYSTEM_STATE_SELF_TEST ");
					prev_system_state = SYSTEM_STATE_SELF_TEST;
					DebugPrintWithTime("Running self-test\r\n");

					//start problem indicators as false,
					//if there is a problem we will change the indcators with an interrupt from the AED.
					AEDAlive = false;
					AED_low_battery = false;
					AED_system_fail = false;

#ifdef NEW_BOARD
					DebugPrintWithTime("Activating Defibrillator\r\n");
					SysCtlDelay(10000000);
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0xff);///P10 PIN2-Open the M&b
					SysCtlDelay(10000000);
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0x00);

					SysCtlDelay(ROM_SysCtlClockGet());

					DebugPrintWithTime("Turning Defibrillator off\r\n");
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0xff);//////P10 PIN2-close the M&b
					SysCtlDelay(30000000);
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0x00);
					SysCtlDelay(10000000);
#else
					DebugPrintWithTime("Activating Defibrillator\r\n");
					SysCtlDelay(10000000);
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_2 ,0x00);///P10 PIN2-Open the M&b
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0xff);
					SysCtlDelay(10000000);
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_2 ,0xff);
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0xff);

					SysCtlDelay(ROM_SysCtlClockGet());

					DebugPrintWithTime("Turning Defibrillator off\r\n");
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_2 ,0x00);//////P10 PIN2-close the M&b
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0xff);
					SysCtlDelay(30000000);
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_2 ,0xff);
					GPIOPinWrite(GPIO_PORTD_BASE,GPIO_PIN_3 ,0xff);
					SysCtlDelay(10000000);
#endif /* NEW_BOARD */

					atp_results_cpu1 = 0;

					if(!AEDAlive)
					{
						atp_results_cpu1 = atp_results_cpu1 | AED_NOT_RESPONDING;
						DebugPrintWithTime("AED Not Responding!!!\r\n");
					}
					if(AED_low_battery)
					{
						atp_results_cpu1 = atp_results_cpu1 | AED_LOW_BAT;
						DebugPrintWithTime("AED Low Battery!!!\r\n");
					}
					if(AED_system_fail)
					{
						atp_results_cpu1 = atp_results_cpu1 | AED_SYS_FAILURE;
						DebugPrintWithTime("AED System Failure!!!\r\n");
					}

					ValidCheckSumFromAED = false;
					state1 = 0;

					DebugPrintWithTime("Checking M101...\r\n");

					mgw830_done_self_check = 0;

					//re-enable the interrupts from the m101
					UARTEnable(UART3_BASE);
					SysCtlDelay(30000000);

					MGW830Send(SETE,2);
					while(!mgw830_done_self_check && door_state == CLOSE){}

					if(door_state == CLOSE)
					{
						//disable the interrupts from the m101
						UARTDisable(UART3_BASE);
					}

					if(mgw830_pass_self_check || door_state == OPEN)
					{
						DebugPrintWithTime("MGW830 check passed\r\n");
					}
					else
					{
						atp_results_cpu1 = atp_results_cpu1 | MGW830_FAILURE;
						DebugPrintWithTime("MGW830 check failed\r\n");
					}

					//if(comm_status_cpu1)
					//{
					DebugPrintWithTime("Sending ATP results to cpu2.\r\n");

					unsigned char atp_res[2] ={0xA1, atp_results_cpu1};
					Write_To_RingBuffer(2, atp_res, 2);
					//}

					if(wake_after_self_test)
					{
						system_state = SYSTEM_STATE_WAKE;
						wake_after_self_test = false;
					}
					else
						system_state = SYSTEM_STATE_SLEEP;
					break;
				}
				//door open ="1" GND ;close="0" VCC
				case SYSTEM_STATE_LOADING:
				{
					create_log_filename();

					//DebugPrint("system_state = SYSTEM_STATE_LOADING \0");
					system_state = SYSTEM_STATE_LOADING_WAIT_FOR_CPU2;

					// Activate data from AED
					ROM_IntEnable(INT_UART4);
					UARTEnable(UART4_BASE);

					// Activate MGW830
					MGW830Send(calibsta, 4);
					MGW830Send(calib, 4);
#ifdef M200_BOARD
					MGW830Send(calibEcgWave, 4);
					MGW830Send(calibEcgLead, 4);
#endif

					ROM_UARTIntEnable(UART3_BASE, UART_INT_RX );
					ROM_IntEnable(INT_UART3);
					IntPrioritySet (INT_UART3, 0);
					UARTEnable(UART3_BASE);

					if(read_file("lang.txt", LANG))
					{
						DebugPrintWithTime("Language file read ");
						lang_a[0] = LANG[0];
						lang_a[1] = LANG[1];
						DebugPrint(lang_a);
						DebugPrint(" and ");

						lang_b[0] = LANG[3];
						lang_b[1] = LANG[4];
						DebugPrint(lang_b);
						DebugPrint(".\r\n");

						char error_lang_a = false;
						char error_lang_b = false;

						if(strncmp(lang_a, "en", 2) &&
								strncmp(lang_a, "de", 2) &&
								strncmp(lang_a, "he", 2) &&
								strncmp(lang_a, "ch", 2))
						{
							error_lang_a = true;
						}
						if(strncmp(lang_b, "en", 2) &&
								strncmp(lang_b, "de", 2) &&
								strncmp(lang_b, "he", 2) &&
								strncmp(lang_b, "ch", 2))
						{
							error_lang_b = true;
						}

						if(error_lang_a || error_lang_b)
						{
							DebugPrintWithTime("Error in language read. loading default.\r\n");
							lang_a[0] = 'd';
							lang_a[1] = 'e';
							lang_b[0] = 'e';
							lang_b[1] = 'n';
						}
					}
					else
					{
						DebugPrintWithTime("Error reading language file. loading default.\r\n");
						lang_a[0] = 'd';
						lang_a[1] = 'e';
						lang_b[0] = 'e';
						lang_b[1] = 'n';
					}

					break;
				}
				case SYSTEM_STATE_LOADING_WAIT_FOR_CPU2:
				{
					unsigned long pullData;

					if(prev_system_state != SYSTEM_STATE_LOADING_WAIT_FOR_CPU2)
					{
						prev_system_state = SYSTEM_STATE_LOADING_WAIT_FOR_CPU2;
						//DebugPrint("system_state = SYSTEM_STATE_LOADING_WAIT_FOR_CPU2");

						ROM_UARTCharPut(UART2_BASE,0x26);
						ROM_UARTCharPut(UART2_BASE,0x88);
					}

					DebugPrintWithTime("Loading is done.\r\n");
					isLoadingDone = true;

					if(door_state == OPEN)
					{
						system_state = SYSTEM_STATE_WAKE;
					}
					else
					{
						system_state = SYSTEM_STATE_SLEEP;
					}
					break;
				}
				case SYSTEM_STATE_BACKDOOR1:
				{
					if(prev_system_state != SYSTEM_STATE_BACKDOOR1)
					{
						//send build version to cpu3
						unsigned char video_build_ver[2] = {0x96, build};
						Write_To_RingBuffer(3, video_build_ver, 2);

						//send atp results to cpu3
						unsigned char video_atp_res[2] = {0xf5, atp_results_cpu1};
						Write_To_RingBuffer(3, video_atp_res, 2);

						unsigned char backdoor1_video[2];
						prev_system_state = SYSTEM_STATE_BACKDOOR1;
						saved_system_state = SYSTEM_STATE_BACKDOOR1;

						backdoor1_video[0] = 0x81;
						backdoor1_video[1] = 21;

						Write_To_RingBuffer(3, backdoor1_video, 2);
					}
					break;
				}
				case SYSTEM_STATE_BACKDOOR2:
				{
					if(prev_system_state != SYSTEM_STATE_BACKDOOR2)
					{
						// send the menu state to the screen
						unsigned char video_menu_state[2] = {0x92, 2};
						Write_To_RingBuffer(3, video_menu_state, 2);

						unsigned char backdoor2_video[2];
						prev_system_state = SYSTEM_STATE_BACKDOOR2;
						saved_system_state = SYSTEM_STATE_BACKDOOR1;

						backdoor2_video[0] = 0x81;
						backdoor2_video[1] = 22;

						Write_To_RingBuffer(3, backdoor2_video, 2);
					}
					break;
				}
				case SYSTEM_STATE_PLACE_HEAD_ON_HEADREST:
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_PLACE_HEAD_ON_HEADREST)
					{
						prev_system_state = SYSTEM_STATE_PLACE_HEAD_ON_HEADREST;
						saved_system_state = SYSTEM_STATE_PLACE_HEAD_ON_HEADREST;
						//DebugPrint("system_state = SYSTEM_STATE_PLACE_HEAD_ON_HEADREST \0");
						update_batt_icon();

						if (door_state) //if the door is open
						{
							wait2 = 2000;

							//we want to count twenty seconds from start of SALI flow.
							during_first_10_seconds = 10 * 200;
							passed_first_sensors_slides = false;

							//sending cpu2 that the door is open
							h[0] = 0x86;

							unsigned char door_open[1] ={h[0]};
							Write_To_RingBuffer(2, door_open, 1);

							DebugPrintWithTime("Sending door open indication to cpu2\r\n");

							//SENDING TIME TO SCREEN
							SysCtlDelay(1000000);

							unsigned char headrest_video[2]={0x81, 0x00};

							Write_To_RingBuffer(3, headrest_video, 2);

							unsigned char headrest[2] = {0x82, 0x00};
							Write_To_RingBuffer(2, headrest, 2);

							DebugPrintWithTime("Sending door open indication to cpu3\r\n");

							SysCtlDelay(1500000);

							MaskAttachedSituation = 0;
							is_first_breath = true;
							cylinderMessageTimes = 0;
						}
					}
					else if (wait2 == 0)
					{
						system_state = SYSTEM_STATE_PLACE_MASK;
					}
					break;
				}
				case SYSTEM_STATE_PLACE_MASK:
				{
					if(prev_system_state != SYSTEM_STATE_PLACE_MASK)
					{
						prev_system_state = SYSTEM_STATE_PLACE_MASK;
						saved_system_state = SYSTEM_STATE_PLACE_MASK;
						//DebugPrint("system_state = SYSTEM_STATE_PLACE_MASK \0");
						unsigned char place_mask_video[2] = {0x81,0x04};

						Write_To_RingBuffer(3, place_mask_video, 2);

						unsigned char place_mask_audio[2]={0x82,0x04};
						Write_To_RingBuffer(2, place_mask_audio, 2);
						SysCtlDelay(1500000);
#ifdef RUN_FAST
						wait2 = 500;
#else
						wait2 = 2000;
#endif
						// Activate MGW830
						MGW830Send(calibsta, 4);
						MGW830Send(calib, 4);
#ifdef M200_BOARD
					    MGW830Send(calibEcgWave, 4);
					    MGW830Send(calibEcgLead, 4);
#endif
					}
					if(wait2 == 0)
					{
						system_state = SYSTEM_STATE_PRESS_GREEN_IF_NO_RESPONSE;

						if(!oxygen_opened)
						{
							// Open Oxygen canister
							ox_flag = 4;
							oxygen=600;
							O2_counter = 200 * 60;
							oxygen_opened = true;
							SSIDataPut(SSI3_BASE, 0xA2);
						}
					}
					break;
				}
				case SYSTEM_STATE_PRESS_GREEN_IF_NO_RESPONSE:
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_PRESS_GREEN_IF_NO_RESPONSE)
					{
						prev_system_state = SYSTEM_STATE_PRESS_GREEN_IF_NO_RESPONSE;
						//DebugPrint("system_state = SYSTEM_STATE_PRESS_GREEN_IF_NO_RESPONSE \0");
						unsigned char GreenButton_video[2]={0x81,0x1};

						Write_To_RingBuffer(3, GreenButton_video, 2);
						unsigned char GreenButton[2]={0x82,0x01};
						Write_To_RingBuffer(2, GreenButton, 2);

						SysCtlDelay(1500000);
						wait2 = 2000;
					}
					else if (wait2 == 0)
					{
						if(saved_system_state == SYSTEM_STATE_PLACE_MASK)
						{
							system_state = SYSTEM_STATE_PLACE_ECG_PADS;
						}
						else
						{
							if(ProbeNotConnected)
							{
								system_state = SYSTEM_STATE_ALL_SENSORS_IN_PLACE;
								silence_probe = 0;
							}
							else if(saved_system_state != SYSTEM_STATE_NONE)
							{
								//if we need to go back to the advanced screen, send to cpu3 the order to show the advanced background.
								if(saved_system_state == SYSTEM_STATE_ADVANCED_SCREEN)
								{
									//unsigned char adv_background[2] = {0x81, 0x11};
									//Write_To_RingBuffer(3, adv_background, 2);
									hr_sources = 0;
								}

								system_state = saved_system_state;
							}
							else
							{
								system_state = SYSTEM_STATE_MONITORING;
							}
						}
					}
					break;
				}
				case SYSTEM_STATE_PLACE_ECG_PADS:
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_PLACE_ECG_PADS)
					{
						prev_system_state = SYSTEM_STATE_PLACE_ECG_PADS;
						saved_system_state = SYSTEM_STATE_PLACE_ECG_PADS;
						//DebugPrint("system_state = SYSTEM_STATE_PLACE_ECG_PADS \0");

						unsigned char ecg_pads_video[2] = {0x81,5};

						Write_To_RingBuffer(3, ecg_pads_video, 2);

						unsigned char ecg_pads_audio[2] = {0x82,5};
						Write_To_RingBuffer(2, ecg_pads_audio, 2);
						SysCtlDelay(1500000);
#ifdef RUN_FAST
						wait2 = 500;
#else
						wait2 = 2000;
#endif
					}
					else if (wait2 == 0)
					{
						system_state = SYSTEM_STATE_PLACE_O2_PROBE;
					}
					break;
				}
				case SYSTEM_STATE_PLACE_O2_PROBE:
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_PLACE_O2_PROBE)
					{
						prev_system_state = SYSTEM_STATE_PLACE_O2_PROBE;
						saved_system_state = SYSTEM_STATE_PLACE_O2_PROBE;
						//DebugPrint("system_state = SYSTEM_STATE_PLACE_O2_PROBE \0");

						unsigned char probe_video[2] = {0x81, 0x6};

						Write_To_RingBuffer(3, probe_video, 2);

						unsigned char probe_audio[2] = {0x82,0x06};
						Write_To_RingBuffer(2, probe_audio, 2);

						wait2 = 2000;
					}
					else if (wait2 == 0)
					{
						system_state = SYSTEM_STATE_ALL_SENSORS_IN_PLACE;
					}
					break;
				}
				///all in place the mask the probe and the ecg stickers
				case SYSTEM_STATE_ALL_SENSORS_IN_PLACE:
				{
					prev_system_state = SYSTEM_STATE_ALL_SENSORS_IN_PLACE;
					saved_system_state = SYSTEM_STATE_ALL_SENSORS_IN_PLACE;

					//DebugPrint("system_state = SYSTEM_STATE_ALL_SENSORS_IN_PLACE \0");

					check_tools();
					break;
				}
				//the oxygen cylinder is empty
				case SYSTEM_STATE_EMPTY_CYLINDER:
				{
					if(prev_system_state != SYSTEM_STATE_EMPTY_CYLINDER)
					{
						unsigned char empty_cylinder_video[2] = {0x81, 0x1A};

						Write_To_RingBuffer(3, empty_cylinder_video, 2);

						unsigned char empty_cylinder_audio[2] = {0x82,0x13};
						Write_To_RingBuffer(2, empty_cylinder_audio, 2);

						prev_system_state = SYSTEM_STATE_EMPTY_CYLINDER;
						wait2 = 2000;
						O2_alert_timer = 26000;
						cylinderMessageTimes++;

						DebugPrintWithTime("Cylinder empty message\r\n");
					}

					if(!wait2)
					{
						if(system_state != SYSTEM_STATE_NONE)
						{
							system_state = SYSTEM_STATE_MONITORING;
						}
						else
						{
							system_state = saved_system_state;
						}

						if(system_state == SYSTEM_STATE_ADVANCED_SCREEN)
						{
							//unsigned char adv_background[2] = {0x81, 0x11};
							//Write_To_RingBuffer(3, adv_background, 2);
						}
					}

					break;
				}
				// Main Monitoring state
				case SYSTEM_STATE_MONITORING:
				{
					// Wait until all checks are done at the timer interrupt
					if(prev_system_state != SYSTEM_STATE_MONITORING)
					{
						// We dont want to redraw if we switch states.
						isToolsChecked = false;
						isMonitoringChecksDone = false;

						while(!(isToolsChecked && isMonitoringChecksDone))
						{
						}
					}

					// First time in state, show the slide.
					if((prev_system_state != SYSTEM_STATE_MONITORING) && !MonitorStatusFlag)
					{
						prev_system_state = SYSTEM_STATE_MONITORING;
						saved_system_state = SYSTEM_STATE_MONITORING;
						//DebugPrint("system_state = SYSTEM_STATE_MONITORING \0");

						unsigned char monitoring_video[2] = {0x81, 0x12};
						Write_To_RingBuffer(3, monitoring_video, 2);

						DebugPrintWithTime("Entering monitoring screen\r\n");

						wait2 = 2000;

						// Activate data from AED
						ROM_IntEnable(INT_UART4);
						UARTEnable(UART4_BASE);

						// Activate MGW830
						MGW830Send(calibsta, 4);
						MGW830Send(calib, 4);
#ifdef M200_BOARD
					    MGW830Send(calibEcgWave, 4);
					    MGW830Send(calibEcgLead, 4);
#endif
					}

					if(qrs)
					{
						//DebugPrint("QRS \0");
						unsigned char video_qrs[1] = {0x89};
						Write_To_RingBuffer(3, video_qrs, 1);

						qrs=0;
					}

					if (wait2 == 0)
					{
						// Redraw state
						//prev_system_state = SYSTEM_STATE_NONE;
					}
					break;
				}
				case SYSTEM_STATE_CHECK_ECG_STICKERS: //check position of clamps
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_CHECK_ECG_STICKERS)
					{
						prev_system_state = SYSTEM_STATE_CHECK_ECG_STICKERS;
						//DebugPrint("system_state = SYSTEM_STATE_CHECK_ECG_STICKERS \0");

						unsigned char check_ecg_video[2]={0x81,0x09};

						Write_To_RingBuffer(3, check_ecg_video, 2);

						unsigned char check_ecg_audio[2]={0x82,0x0a};
						Write_To_RingBuffer(2, check_ecg_audio, 2);

						wait2 = 2000;
					}
					else if(wait2 == 0)
					{
						system_state = SYSTEM_STATE_ALL_SENSORS_IN_PLACE;
					}
					break;
				}
				case SYSTEM_STATE_CHECK_PROBE: //check position of Probe
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_CHECK_PROBE)
					{
						prev_system_state = SYSTEM_STATE_CHECK_PROBE;
						//DebugPrint("system_state = SYSTEM_STATE_CHECK_PROBE \0");

						unsigned char check_probe_video[2] = {0x81,0x8};
						Write_To_RingBuffer(3, check_probe_video, 2);

						unsigned char check_probe_audio[2] = {0x82,0x09};
						Write_To_RingBuffer(2, check_probe_audio, 2);

						wait2 = 2000;
					}
					else if(wait2 == 0)
					{
						system_state = SYSTEM_STATE_ALL_SENSORS_IN_PLACE;
					}
					break;
				}
				case SYSTEM_STATE_CHECK_MASK://check position of mask
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_CHECK_MASK)
					{
						prev_system_state = SYSTEM_STATE_CHECK_MASK;
						//DebugPrint("system_state = SYSTEM_STATE_CHECK_MASK \0");

						unsigned char check_mask_video[2]={0x81,0xa};

						Write_To_RingBuffer(3, check_mask_video, 2);

						unsigned char check_mask_audio[2] = {0x82, 0x0b};
						Write_To_RingBuffer(2, check_mask_audio, 2);

						wait2 = 2000;
					}
					else if(wait2 == 0)
					{
						system_state = SYSTEM_STATE_ALL_SENSORS_IN_PLACE;
					}
					break;
				}
				case SYSTEM_STATE_REMOVE_SECRETION://Remove secretion
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_REMOVE_SECRETION)
					{
						prev_system_state = SYSTEM_STATE_REMOVE_SECRETION;
						//DebugPrint("system_state = SYSTEM_STATE_REMOVE_SECRETION \0");

						unsigned char remove_secretion_video[2] = {0x81, 0x10};

						Write_To_RingBuffer(3, remove_secretion_video, 2);

						unsigned char remove_secretion_audio[2] = {0x82, 0x11};
						Write_To_RingBuffer(2, remove_secretion_audio, 2);

						wait2 = 2000;
					}
					else if(wait2 == 0)
					{
						system_state = SYSTEM_STATE_ALL_SENSORS_IN_PLACE;
					}
					break;
				}
				case SYSTEM_STATE_START_CPR: //Start cpr
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_START_CPR)
					{
						prev_system_state = SYSTEM_STATE_START_CPR;
						//DebugPrint("system_state = SYSTEM_STATE_START_CPR \0");
						events[EVENT_CPR] = true;

						unsigned char cpr_event[1] ={0x92};
						Write_To_RingBuffer(2, cpr_event, 1);

						New_Event();
						system_status = SYSTEM_STATUS_CPR;

						unsigned char start_cpr_video[2] = {0x81, 0x0b};

						Write_To_RingBuffer(3, start_cpr_video, 2);

						unsigned char start_cpr_audio[2] = {0x82, 0x0c};
						Write_To_RingBuffer(2, start_cpr_audio, 2);

						wait2 = 1000;
					}
					if(wait2 == 0)
					{
						//DebugPrint("changing to SYSTEM_STATE_CPR_HAND_LOCATION \n");
						system_state = SYSTEM_STATE_CPR_HAND_LOCATION;
					}
					break;
				}
				case SYSTEM_STATE_CPR_HAND_LOCATION: // Instruct CPR hand position
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_CPR_HAND_LOCATION)
					{
						prev_system_state = SYSTEM_STATE_CPR_HAND_LOCATION;
						//DebugPrint("system_state = SYSTEM_STATE_CPR_HAND_LOCATION \0");

						//ROM_UARTCharPut(UART0_BASE,0x11);
						unsigned char cpr_hands_picture[2]={0x81,0x0C};

						Write_To_RingBuffer(3, cpr_hands_picture, 2);

						unsigned char cpr_hands_sound[2]={0x82,0x0D};
						Write_To_RingBuffer(2, cpr_hands_sound, 2);

						wait2 = 1400;
					}
					if(wait2 == 0)
					{
						system_state = SYSTEM_STATE_CPR_START_PUSH;
					}
					break;
				}
				case SYSTEM_STATE_CPR_START_PUSH: // Instruct CPR hand position
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_CPR_START_PUSH)
					{
						prev_system_state = SYSTEM_STATE_CPR_START_PUSH;
						//DebugPrint("system_state = SYSTEM_STATE_CPR_START_PUSH \0");

						//ROM_UARTCharPut(UART0_BASE,0x11);
						unsigned char cpr_start_push_picture[2]={0x81,0x0D};

						Write_To_RingBuffer(3, cpr_start_push_picture, 2);

						unsigned char cpr_start_push_sound[2]={0x82,0x0E};
						Write_To_RingBuffer(2, cpr_start_push_sound, 2);

						wait2 = 1400;

						MonitorStatusFlag = 0;
					}
					if(wait2 == 0)
					{
						system_state = SYSTEM_STATE_CPR_PUSH;
					}
					break;
				}
				case SYSTEM_STATE_CPR_PUSH: // Instruct CPR push
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_CPR_PUSH)
					{
						// count 1 minute to put "pay attention" slide
						if(prev_system_state != SYSTEM_STATE_NONE)
							count_cpr_push = 0;

						prev_system_state = SYSTEM_STATE_CPR_PUSH;
						//DebugPrint("system_state = SYSTEM_STATE_CPR_PUSH \0");
						usprintf(str,"[count_cpr_push = %d] \0",count_cpr_push);
						DebugPrintWithTime(str);
						DebugPrint("\r\n");

						unsigned char cpr_push_picture[2]={0x81,0x0E};

						Write_To_RingBuffer(3, cpr_push_picture, 2);

						unsigned char cpr_push_sound[2]={0x82,0x0F};
						Write_To_RingBuffer(2, cpr_push_sound, 2);

						wait2 = 600;
					}
					if(wait2 == 0)
					{
						if(count_cpr_push == 20)
						{
							/*if(cpr_from_sali && heart_rate > 50 && heart_rate < 180)
							{
								system_state = SYSTEM_STATE_STOP_CPR;
								count_cpr_push = 0;
							}
							else
							{*/
							system_state = SYSTEM_STATE_PAY_ATTENTION_CPR;
							//}
						}
						else
						{
							prev_system_state = SYSTEM_STATE_NONE;
						}
						count_cpr_push++;
					}
					break;
				}
				case SYSTEM_STATE_PAY_ATTENTION_CPR: // Instruct to pay attention to patient during CPR
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_PAY_ATTENTION_CPR)
					{
						prev_system_state = SYSTEM_STATE_PAY_ATTENTION_CPR;
						//DebugPrint("system_state = SYSTEM_STATE_PAY_ATTENTION_CPR \0");

						unsigned char cpr_attention_picture[2]={0x81,0x18};

						Write_To_RingBuffer(3, cpr_attention_picture, 2);

						unsigned char cpr_attention_sound[2]={0x82,0x17};
						Write_To_RingBuffer(2, cpr_attention_sound, 2);

						wait2 = 1200;
						count_cpr_push -= 2;
					}
					if(wait2 == 0)
					{
						system_state = SYSTEM_STATE_CPR_PUSH;
					}
					break;
				}
				case SYSTEM_STATE_STOP_CPR: // Instruct stop CPR
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_STOP_CPR)
					{
						prev_system_state = SYSTEM_STATE_STOP_CPR;
						//DebugPrint("system_state = SYSTEM_STATE_STOP_CPR \0");

						unsigned char stop_cpr_picture[2]={0x81,0x17};

						Write_To_RingBuffer(3, stop_cpr_picture, 2);

						unsigned char cpr_stop_sound[2]={0x82,0x1A};
						Write_To_RingBuffer(2, cpr_stop_sound, 2);

						wait2 = 2000;
					}
					if(wait2 == 0)
					{
						//make sure we start checking from scratch for next cpr.
						vf_cpr_counter = 0;
						vf_cpr_timer = 2000;
						CprDueToVF = false;
						count_hr_cpr = 3000;

						//move on...
						system_state = SYSTEM_STATE_ALL_SENSORS_IN_PLACE;
						system_status = SYSTEM_STATUS_NONE;
					}
					break;
				}
				case SYSTEM_STATE_ANALYSIS: //Analyzing
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_ANALYSIS)
					{
						prev_system_state = SYSTEM_STATE_ANALYSIS;
						//DebugPrint("system_state = SYSTEM_STATE_ANALYSIS \0");

						unsigned char analysis_video [2] = {0x81,0x03};
						Write_To_RingBuffer(3, analysis_video, 2);

						unsigned char analysis_audio[2] = {0x82, 0x03};
						Write_To_RingBuffer(2, analysis_audio, 2);
					}
					break;
				}
				case SYSTEM_STATE_CHARGING_DONT_TOUCH: //charging AED
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_CHARGING_DONT_TOUCH)
					{
						prev_system_state = SYSTEM_STATE_CHARGING_DONT_TOUCH;
						//DebugPrint("system_state = SYSTEM_STATE_CHARGING_DONT_TOUCH \0");

						unsigned char AED_charging_video [2] = {0x81,0x1D};
						Write_To_RingBuffer(3, AED_charging_video, 2);

						unsigned char AED_charging_audio[2] = {0x82, 0x1C};
						Write_To_RingBuffer(2, AED_charging_audio, 2);
					}
					break;
				}
				case SYSTEM_STATE_CHECK_PADS: //check pads
				{
					static int check_pads_phase_flag = 0;

					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_CHECK_PADS)
					{
						prev_system_state = SYSTEM_STATE_CHECK_PADS;
						//DebugPrint("system_state = SYSTEM_STATE_CHECK_PADS \0");

						unsigned char first_check_pads_video[2] = {0x81, 0x1B};

						Write_To_RingBuffer(3, first_check_pads_video, 2);

						unsigned char check_pads_audio[2]={0x82, 0x02};
						Write_To_RingBuffer(2, check_pads_audio, 2);

						check_pads_phase_flag = 1;

						wait2 = 1600;
					}

					if(wait2 == 0)
					{
						if(check_pads_phase_flag == 1)
						{
							unsigned char second_check_pads_video[2] = {0x81, 0x02};

							Write_To_RingBuffer(3, second_check_pads_video, 2);

							unsigned char check_pads_audio[2]={0x82, 0x02};
							Write_To_RingBuffer(2, check_pads_audio, 2);

							wait2 = 2000;

							check_pads_phase_flag = 2;
						}
						else
						{
							prev_system_state = SYSTEM_STATUS_NONE;
							check_pads_phase_flag = 0;
						}
					}
					break;
				}
				case SYSTEM_STATE_PRESS_RED: //Shock advised
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_PRESS_RED)
					{
						prev_system_state = SYSTEM_STATE_PRESS_RED;
						//DebugPrint("system_state = SYSTEM_STATE_PRESS_RED \0");

						unsigned char press_red[2] = {0x81, 0x07};

						Write_To_RingBuffer(3, press_red, 2);

						unsigned char press_red_audio[2] = {0x82, 0x08};
						Write_To_RingBuffer(2, press_red_audio, 2);
						wait2 = 2000;
					}
					if(wait2 == 0)
					{
						prev_system_state = SYSTEM_STATUS_NONE;
					}
					break;
				}
				case SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN:
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN)
					{
						wait2 = 2000;

						prev_system_state = SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN;
						//DebugPrint("system_state = SYSTEM_STATE_NO_RESPONSE_PRESS_GREEN \0");

						if(!defib_activated)
						{
							unsigned char no_responce_video[2]={0x81,0x0f};

							Write_To_RingBuffer(3, no_responce_video, 2);

							unsigned char no_responce_audio[2]={0x82,0x10};
							Write_To_RingBuffer(2, no_responce_audio, 2);
						}

					}
					if(wait2 == 0)
					{
						// redraw state;
						prev_system_state = SYSTEM_STATE_NONE;
					}
					break;
				}
				case SYSTEM_STATE_SHOCK_DELIVERED:
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_SHOCK_DELIVERED)
					{
						prev_system_state = SYSTEM_STATE_SHOCK_DELIVERED;
						//DebugPrint("system_state = SYSTEM_STATE_SHOCK_DELIVERED \0");

						unsigned char shock_delivered_video[2]={0x81,0x13};

						Write_To_RingBuffer(3, shock_delivered_video, 2);

						unsigned char shock_delivered_audio[2]={0x82,0x15};
						Write_To_RingBuffer(2, shock_delivered_audio, 2);

						wait2 = 2000;
					}

					if(wait2 == 0)
					{
						system_status = SYSTEM_STATUS_NONE;
						shock_not_advised_flag = true;

						if(saved_system_state == SYSTEM_STATE_ADVANCED_SCREEN)
						{
							system_state = saved_system_state;
							prev_system_state = SYSTEM_STATE_NONE;
							hr_sources = 0;
						}
						else
						{
							system_state =  SYSTEM_STATE_ALL_SENSORS_IN_PLACE;
						}
					}
					break;
				}
				case SYSTEM_STATE_NO_SHOCK:
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_NO_SHOCK)
					{
						prev_system_state = SYSTEM_STATE_NO_SHOCK;
						//DebugPrint("system_state = SYSTEM_STATE_NO_SHOCK \0");

						unsigned char no_shock_video[2]={0x81,0x1C};

						Write_To_RingBuffer(3, no_shock_video, 2);

						unsigned char no_shock_audio[2]={0x82,0x1B};
						Write_To_RingBuffer(2, no_shock_audio, 2);
					}
					break;
				}
				//CLOSING THE DOOR WAITING FOR 15 MINU TO GO TO SLEEP
				case SYSTEM_STATE_STANDBY:
				{
					DebugPrintWithTime("Entering standby situation, starting 15 minute wait\r\n");
					//DebugPrint("system_state = SYSTEM_STATE_STANDBY \0");
					WaitInStandby = 200 * 60 * 15; // 15 sleep after minutes.

					//put to sleep cpu3
					unsigned char video_sleep[1] = {0xf0};
					Write_To_RingBuffer(3, video_sleep, 1);
					system_state = SYSTEM_STATE_COUNT_15_MINUTES;

					DebugPrintWithTime("shutting down video\r\n");

					// Mute the volume
					unsigned char mute_vol[2] = {0x82, 100};
					Write_To_RingBuffer(2, mute_vol, 2);

					DebugPrintWithTime("Muting volume\r\n");

					break;
				}

				case SYSTEM_STATE_COUNT_15_MINUTES:///waiting to sleep or wake up
				{
					//DebugPrint("system_state = 22 waiting to sleep or wake up \0");
					break;
				}

				case SYSTEM_STATE_LOW_BATT: // turn off sali, low battery
				{
					// First time in state, show the slide.
					if(prev_system_state != SYSTEM_STATE_LOW_BATT)
					{
						prev_system_state = SYSTEM_STATE_LOW_BATT;
						//DebugPrint("system_state = SYSTEM_STATE_LOW_BATT \0");

						unsigned char low_batt_picture[2]={0x81,0x19};
						Write_To_RingBuffer(3, low_batt_picture, 2);

						unsigned char low_batt_audio[2]={0x82,0x12};
						Write_To_RingBuffer(2, low_batt_audio, 2);

						wait2 = 6000;

						DebugPrintWithTime("Battery very low\r\n");
					}
					if(wait2 == 0)
					{
						system_state = SYSTEM_STATE_SLEEP;
						system_status = SYSTEM_STATUS_NONE;
					}
					break;
				}

				case SYSTEM_STATE_ADVANCED_SCREEN://sending data in advance screen
				{
					if(prev_system_state != SYSTEM_STATE_ADVANCED_SCREEN)
					{
						prev_system_state = SYSTEM_STATE_ADVANCED_SCREEN;

						unsigned char adv_background[2] = {0x81, 0x11};
						Write_To_RingBuffer(3, adv_background, 2);

						// Activate MGW830
						MGW830Send(calibsta, 4);
						MGW830Send(calib, 4);
#ifdef M200_BOARD
					    MGW830Send(calibEcgWave, 4);
					    MGW830Send(calibEcgLead, 4);
#endif

						if(!oxygen_opened)
						{
							// Open Oxygen canister
							ox_flag = 4;
							oxygen=600;
							O2_counter = 200 * 60;
							oxygen_opened = true;
							SSIDataPut(SSI3_BASE, 0xA2);

							DebugPrintWithTime("Opening oxygen if not opened yet\r\n");
						}
					}

					// Send ECG wave to screen
					if(send_ecg_to_screen)
					{
						//DebugPrint("Send ECG wave to screen ");
						send_ecg_to_screen = false;
						RingBufWrite(&sRingBuf_adv, heart_rate_uart_send, 11);
					}
					while((!(RingBufEmpty(&sRingBuf_adv)))&& (UARTSpaceAvail(UART5_BASE)) )
					{
						t = RingBufReadOne(&sRingBuf_adv);
						ROM_UARTCharPut(UART5_BASE,t);
					}
					break;
				}
				case SYSTEM_STATE_NONE:
				{
					if((saved_system_state == SYSTEM_STATE_BACKDOOR1) || (saved_system_state == SYSTEM_STATE_BACKDOOR2))
					{
						system_state = saved_system_state;
					}
					break;
				}
				default:
					break;
				}
			}
		}
	}
#endif
}
